{"version":3,"file":"Callout.types.js","sourceRoot":"../src/","sources":["components/Callout/Callout.types.ts"],"names":[],"mappings":"","sourcesContent":["import { IStyle, ITheme } from '../../Styling';\nimport { DirectionalHint } from '../../common/DirectionalHint';\nimport {\n  IPoint,\n  IRectangle\n} from '../../Utilities';\nimport { ICalloutPositionedInfo } from '../../utilities/positioning';\nimport { IStyleFunction } from '../../Utilities';\n\nexport interface ICallout {\n\n}\n\nexport interface ICalloutProps {\n  /**\n   * Optional callback to access the ICallout interface. Use this instead of ref for accessing\n   * the public methods and properties of the component.\n   */\n  componentRef?: (component: ICallout | null) => void;\n\n  /**\n   * The target that the Callout should try to position itself based on.\n   * It can be either an Element a querySelector string of a valid Element\n   * or a MouseEvent. If MouseEvent is given then the origin point of the event will be used.\n   */\n  target?: Element | string | MouseEvent | IPoint | null;\n\n  /**\n   * How the element should be positioned\n   * @default DirectionalHint.BottomAutoEdge\n   */\n  directionalHint?: DirectionalHint;\n\n  /**\n   * How the element should be positioned in RTL layouts.\n   * If not specified, a mirror of `directionalHint` will be used instead\n   */\n  directionalHintForRTL?: DirectionalHint;\n\n  /**\n   * The gap between the Callout and the target\n   * @default 0\n   */\n  gapSpace?: number;\n\n  /**\n   * The width of the beak.\n   * @default 16\n   */\n  beakWidth?: number;\n\n  /**\n   * Custom width for callout including borders. If value is 0, no width is applied.\n   * @default 0\n   */\n  calloutWidth?: number;\n\n  /**\n   * The background color of the Callout in hex format ie. #ffffff.\n   * @default $ms-color-white\n   */\n  backgroundColor?: string;\n\n  /**\n   * The bounding rectangle for which  the contextual menu can appear in.\n   */\n  bounds?: IRectangle;\n\n  /**\n   * The minimum distance the callout will be away from the edge of the screen.\n   *  @default 8\n   */\n  minPagePadding?: number;\n\n  /**\n   * If true use a point rather than rectangle to position the Callout.\n   * For example it can be used to position based on a click.\n   * @deprecated Use 'target' instead\n   */\n  useTargetPoint?: boolean;\n\n  /**\n   * Point used to position the Callout\n   * @deprecated Use 'target' instead\n   */\n  targetPoint?: IPoint;\n\n  /**\n   * If true then the beak is visible. If false it will not be shown.\n   * @default true\n   */\n  isBeakVisible?: boolean;\n\n  /**\n   * If true then the onClose will not not dismiss on scroll\n   * @default false\n   */\n  preventDismissOnScroll?: boolean;\n\n  /**\n   * If true the position returned will have the menu element cover the target.\n   * If false then it will position next to the target;\n   * @default false\n   */\n  coverTarget?: boolean;\n\n  /**\n   * Aria role assigned to the callout (Eg. dialog, alertdialog).\n   */\n  role?: string;\n\n  /**\n   * Accessible label text for callout.\n   */\n  ariaLabel?: string;\n\n  /**\n   *  Defines the element id referencing the element containing label text for callout.\n   */\n  ariaLabelledBy?: string;\n\n  /**\n   * Defines the element id referencing the element containing the description for the callout.\n   */\n  ariaDescribedBy?: string;\n\n  /**\n   * CSS class to apply to the callout.\n   * @default null\n   */\n  className?: string;\n\n  /**\n   * CSS style to apply to the callout.\n   */\n  style?: React.CSSProperties;\n\n  /**\n   * Optional callback when the layer content has mounted.\n   */\n  onLayerMounted?: () => void;\n\n  /**\n   * Optional callback that is called once the callout has been correctly positioned.\n   * @param {ICalloutPositionedInfo} positions gives the user information about how the callout is positioned such as the\n   * final edge of the target that it positioned against, the beak position, and the beaks relationship to the\n   * edges of the callout.\n   */\n  onPositioned?: (positions?: ICalloutPositionedInfo) => void;\n\n  /**\n   * Callback when the Callout tries to close.\n   */\n  onDismiss?: (ev?: any) => void;\n\n  /**\n   * If true do not render on a new layer. If false render on a new layer.\n   */\n  doNotLayer?: boolean;\n\n  /**\n   * If true the position will not change sides in an attempt to fit the callout within bounds.\n   * It will still attempt to align it to whatever bounds are given.\n   * @default false\n   */\n  directionalHintFixed?: boolean;\n\n  /**\n   * Specify the final height of the content.\n   * To be used when expanding the content dynamically so that callout can adjust its position.\n   */\n  finalHeight?: number;\n\n  /**\n   * If true then the callout will attempt to focus the first focusable element that it contains.\n   * If it doesn't find an element, no focus will be set and the method will return false.\n   * This means that it's the contents responsibility to either set focus or have\n   * focusable items.\n   * @returns True if focus was set, false if it was not.\n   */\n  setInitialFocus?: boolean;\n\n  /**\n    * Deprecated at v0.59.1, to be removed at >= v1.0.0. Pass in a beakWidth to dictate size.\n    * @deprecated\n    */\n  beakStyle?: string;\n\n  /**\n   * Set max height of callout\n   * When not set the callout will expand with contents up to the bottom of the screen\n   */\n  calloutMaxHeight?: number;\n\n  /**\n   * Callback when the Callout body is scrolled.\n   */\n  onScroll?: () => void;\n\n  /**\n   * Optional theme for component\n   */\n  theme?: ITheme;\n\n  /**\n   * Optional styles for the component.\n   */\n  getStyles?: IStyleFunction<ICalloutContentStyleProps, ICalloutContentStyles>;\n\n  /**\n   * If specified, renders the Callout in a hidden state.\n   * Use this flag, rather than rendering a callout conditionally based on visibility,\n   * to improve rendering performance when it becomes visible.\n   * Note: When callout is hidden its content will not be rendered. It will only render\n   * once the callout is visible.\n   */\n  hidden?: boolean;\n}\n\nexport interface ICalloutContentStyleProps {\n  /**\n   * Theme to apply to the calloutContent.\n   */\n  theme: ITheme;\n\n  /**\n   * Width for callout including borders.\n   */\n  calloutWidth?: number;\n\n  /**\n * CSS class to apply to the callout.\n */\n  className?: string;\n\n  /**\n   * Callout positioning data\n   */\n  positions?: ICalloutPositionedInfo;\n\n  /**\n   * Whether or not to clip content of the callout,\n   * if it overflows vertically.\n   */\n  overflowYHidden?: boolean;\n\n  /**\n   * @deprecated will be removed in v6. Do not use.\n   * Max height applied to the content of a callout.\n   */\n  contentMaxHeight?: number;\n\n  /**\n   * Background color for the beak and callout.\n   */\n  backgroundColor?: string;\n\n  /**\n   * Width of Callout beak\n   */\n  beakWidth?: number;\n\n  /**\n    * Deprecated at v0.59.1, to be removed at >= v1.0.0. Pass in a beakWidth to dictate size.\n    * @deprecated\n    */\n  beakStyle?: string;\n}\n\nexport interface ICalloutContentStyles {\n  /**\n   * Style for wrapper of Callout component.\n   */\n  container: IStyle;\n\n  /**\n  * Style for callout container root element.\n  */\n  root: IStyle;\n\n  /**\n  * Style for callout beak.\n  */\n  beak: IStyle;\n\n  /**\n  * Style for callout beak curtain.\n  */\n  beakCurtain: IStyle;\n\n  /**\n  * Style for content component of the callout.\n  */\n  calloutMain: IStyle;\n}\n"]}