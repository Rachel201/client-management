{"version":3,"file":"Router.js","sourceRoot":"../src/","sources":["utilities/router/Router.tsx"],"names":[],"mappings":";;;IAcA;QAA4B,kCAA+B;QAA3D;;QA2EA,CAAC;QA1EQ,kCAAiB,GAAxB;YAAA,iBAEC;YADC,IAAI,CAAC,OAAO,CAAC,EAAE,CAAC,MAAM,EAAE,YAAY,EAAE,cAAM,OAAA,KAAI,CAAC,WAAW,EAAE,EAAlB,CAAkB,CAAC,CAAC;QAClE,CAAC;QAEM,uBAAM,GAAb;YACE,OAAO,IAAI,CAAC,aAAa,EAAE,CAAC;QAC9B,CAAC;QAEO,yBAAQ,GAAhB;YACE,IAAI,IAAI,GAAG,QAAQ,CAAC,IAAI,CAAC;YACzB,IAAM,SAAS,GAAG,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,EACrC,iBAAiB,GAAG,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;YAExC,gHAAgH;YAChH,IAAI,iBAAiB,GAAG,CAAC,CAAC,EAAE;gBAC1B,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,iBAAiB,CAAC,CAAC;aAC1C;YAED,IAAI,SAAS,GAAG,CAAC,EAAE;gBACjB,IAAI,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,EAAE,SAAS,CAAC,CAAC;aAClC;YAED,OAAO,IAAI,CAAC;QACd,CAAC;QAEO,8BAAa,GAArB,UAAsB,IAAa,EAAE,QAA0B;YAA/D,iBA+CC;YA9CC,IAAI,GAAG,IAAI,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YAC/B,QAAQ,GAAG,QAAQ,IAAI,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC;YAE3C,IAAM,MAAM,GAAG,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;oCAEvC,CAAC;gBACR,IAAM,KAAK,GAAQ,MAAM,CAAC,CAAC,CAAC,CAAC;gBAE7B,IAAI,MAAM,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE;oBACf,IAAA,yCAAY,CAAiB;oBAC/B,IAAA,mCAAS,CAAiB;oBAEhC,IAAI,cAAY,EAAE;wBAChB,IAAI,wBAAsB,GAAG,KAAK,CAAC;wBAEnC,IAAI,cAAY,CAAC,SAAS,EAAE;4BAC1B,WAAS,GAAG,cAAY,CAAC,SAAS,CAAC;yBACpC;6BAAM;4BACL,cAAY,CAAC,UAAC,QAAa;gCACzB,WAAS,GAAG,cAAY,CAAC,SAAS,GAAG,QAAQ,CAAC;gCAE9C,IAAI,wBAAsB,EAAE;oCAC1B,KAAI,CAAC,WAAW,EAAE,CAAC;iCACpB;4BACH,CAAC,CAAC,CAAC;yBACJ;wBACD,iDAAiD;wBACjD,wBAAsB,GAAG,IAAI,CAAC;qBAC/B;oBAED,IAAI,WAAS,EAAE;wBACb,IAAM,iBAAiB,GAAG,OAAK,aAAa,CAAC,IAAI,EAAE,KAAK,CAAC,KAAK,CAAC,QAAQ,IAAI,EAAE,CAAC,CAAC;wBAE/E,IAAI,iBAAiB,EAAE;4CACd,KAAK,CAAC,aAAa,CAAC,WAAS,EAAE,EAAE,GAAG,EAAE,KAAK,CAAC,GAAG,EAAE,EAAE,iBAAiB,CAA+B;yBAC3G;6BAAM;4CACE,KAAK,CAAC,aAAa,CAAC,WAAS,EAAE,EAAE,GAAG,EAAE,KAAK,CAAC,GAAG,EAAE,CAA+B;yBACxF;qBACF;yBAAM,IAAI,cAAY,EAAE;wCAEhB,IAAI;qBACZ;iBACF;YACH,CAAC;;YAtCD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE;sCAA7B,CAAC;;;aAsCT;YAED,OAAO,IAAI,CAAC;QACd,CAAC;QAEH,aAAC;IAAD,CAAC,AA3ED,CAA4B,yBAAa,GA2ExC;IA3EY,wBAAM;IA6EnB,gBAAgB,WAAmB,EAAE,KAAU;QAC7C,IAAI,KAAK,CAAC,KAAK,EAAE;YACT,IAAA,uBAAI,CAAiB;YAE3B,IAAI,GAAG,IAAI,IAAI,EAAE,CAAC;YAClB,WAAW,GAAG,WAAW,IAAI,EAAE,CAAC;YAEhC,OAAO,CACL,CAAC,CAAC,IAAI,CAAC;gBACP,CAAC,IAAI,CAAC,WAAW,EAAE,KAAK,WAAW,CAAC,WAAW,EAAE,CAAC,CACnD,CAAC;SACH;QAED,OAAO,KAAK,CAAC;IACf,CAAC","sourcesContent":["import * as React from 'react';\nimport { BaseComponent } from '../../Utilities';\n\nexport interface IRouterProps {\n  /**\n   * Gets the component ref.\n   */\n  componentRef?: () => void;\n\n  replaceState?: boolean;\n  children?: any;\n  onNewRouteLoaded?: () => void;\n}\n\nexport class Router extends BaseComponent<IRouterProps, {}> {\n  public componentDidMount(): void {\n    this._events.on(window, 'hashchange', () => this.forceUpdate());\n  }\n\n  public render(): JSX.Element | null {\n    return this._resolveRoute();\n  }\n\n  private _getPath(): string {\n    let path = location.hash;\n    const hashIndex = path.lastIndexOf('#'),\n      questionMarkIndex = path.indexOf('?');\n\n    // Look for the start of a query in the currentPath, then strip out the query to find the correct page to render\n    if (questionMarkIndex > -1) {\n      path = path.substr(0, questionMarkIndex);\n    }\n\n    if (hashIndex > 0) {\n      path = path.substr(0, hashIndex);\n    }\n\n    return path;\n  }\n\n  private _resolveRoute(path?: string, children?: React.ReactNode): React.DOMElement<any, Element> | null {\n    path = path || this._getPath();\n    children = children || this.props.children;\n\n    const routes = React.Children.toArray(children);\n\n    for (let i = 0; i < routes.length; i++) {\n      const route: any = routes[i];\n\n      if (_match(path, route)) {\n        const { getComponent } = route.props;\n        let { component } = route.props;\n\n        if (getComponent) {\n          let asynchronouslyResolved = false;\n\n          if (getComponent.component) {\n            component = getComponent.component;\n          } else {\n            getComponent((resolved: any) => {\n              component = getComponent.component = resolved;\n\n              if (asynchronouslyResolved) {\n                this.forceUpdate();\n              }\n            });\n          }\n          // Note: in webpack 2, this ends up always async.\n          asynchronouslyResolved = true;\n        }\n\n        if (component) {\n          const componentChildren = this._resolveRoute(path, route.props.children || []);\n\n          if (componentChildren) {\n            return React.createElement(component, { key: route.key }, componentChildren) as React.DOMElement<any, any>;\n          } else {\n            return React.createElement(component, { key: route.key }) as React.DOMElement<any, any>;\n          }\n        } else if (getComponent) {\n          // We are asynchronously fetching this component.\n          return null;\n        }\n      }\n    }\n\n    return null;\n  }\n\n}\n\nfunction _match(currentPath: string, child: any): boolean {\n  if (child.props) {\n    let { path } = child.props;\n\n    path = path || '';\n    currentPath = currentPath || '';\n\n    return (\n      (!path) ||\n      (path.toLowerCase() === currentPath.toLowerCase())\n    );\n  }\n\n  return false;\n}"]}