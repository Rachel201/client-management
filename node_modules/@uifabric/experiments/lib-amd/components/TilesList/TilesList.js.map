{"version":3,"file":"TilesList.js","sourceRoot":"../src/","sources":["components/TilesList/TilesList.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  ITilesListProps,\n  ITilesGridItem,\n  ITilesGridSegment,\n  TilesGridMode,\n  ITileSize,\n  ITilesGridItemCellProps,\n  ITilesListRowProps,\n  ITilesListRootProps,\n} from './TilesList.types';\nimport { List, IPageProps, ScrollToMode, IListOnRenderRootProps } from 'office-ui-fabric-react/lib/List';\nimport { FocusZone, FocusZoneDirection } from 'office-ui-fabric-react/lib/FocusZone';\nimport {\n  css,\n  IRenderFunction,\n  IRectangle,\n  FocusRects,\n  composeRenderFunction,\n} from 'office-ui-fabric-react/lib/Utilities';\nimport * as TilesListStylesModule from './TilesList.scss';\nimport { Shimmer } from 'office-ui-fabric-react/lib/Shimmer';\n\nconst TilesListStyles: any = TilesListStylesModule;\n\nconst MAX_TILE_STRETCH = 1.5;\nconst CELLS_PER_PAGE = 100;\nconst MIN_ASPECT_RATIO = 0.5;\nconst MAX_ASPECT_RATIO = 3;\n\nconst ROWS_OF_PLACEHOLDER_CELLS = 3;\n\nexport interface ITilesListState<TItem> {\n  cells: ITileCell<TItem>[];\n}\n\n/**\n * @internal\n */\nexport interface ITileGrid {\n  minRowHeight: number;\n  mode: TilesGridMode;\n  spacing: number;\n  maxScaleFactor: number;\n  marginTop: number;\n  marginBottom: number;\n  key: string;\n  isPlaceholder?: boolean;\n  maxRowCount?: number;\n}\n\n/**\n * @internal\n */\nexport interface ITileCell<TItem> {\n  key: string;\n  content: TItem;\n  aspectRatio: number;\n  grid: ITileGrid;\n  isPlaceholder?: boolean;\n  desiredHeight?: number;\n  onRender(props: {\n    item: TItem;\n    finalSize: {\n      width: number;\n      height: number;\n    };\n    position: {\n      column: number;\n    };\n  }): React.ReactNode;\n}\n\ninterface IRowData {\n  scaleFactor: number;\n  cellCount: number;\n  isLastRow?: boolean;\n  maxScaleFactor?: number;\n}\n\ninterface IPageData<TItem> {\n  pageWidths: {\n    [index: number]: number;\n  };\n  rows: {\n    [index: number]: IRowData;\n  };\n  cellSizes: {\n    [index: number]: ITileSize;\n  };\n  extraCells: ITileCell<TItem>[] | undefined;\n}\n\ninterface IPageSpecification<TItem> {\n  itemCount: number;\n  data: IPageData<TItem>;\n}\n\ninterface IPageSpecificationCache<TItem> {\n  byIndex: {\n    [index: number]: IPageSpecification<TItem>;\n  };\n  width: number;\n}\n\n/**\n * Component which renders a virtualized flexbox list of 'tiles', which have arbitrary width and height\n * and which support scaling to fill rows when needed.\n */\nexport class TilesList<TItem> extends React.Component<ITilesListProps<TItem>, ITilesListState<TItem>> {\n  private _pageSpecificationCache: IPageSpecificationCache<TItem> | undefined;\n  private listRef: React.RefObject<List>;\n\n  constructor(props: ITilesListProps<TItem>, context: any) {\n    super(props, context);\n\n    this.listRef = React.createRef();\n\n    this.state = {\n      cells: this._getCells(props.items),\n    };\n  }\n\n  public UNSAFE_componentWillReceiveProps(nextProps: ITilesListProps<TItem>): void {\n    if (nextProps.items !== this.props.items) {\n      this.setState({\n        cells: this._getCells(nextProps.items),\n      });\n    }\n  }\n\n  public UNSAFE_componentWillUpdate(nextProps: ITilesListProps<TItem>, nextState: ITilesListState<TItem>): void {\n    if (nextState.cells !== this.state.cells) {\n      this._pageSpecificationCache = undefined;\n    }\n  }\n\n  public render(): JSX.Element {\n    const { cells } = this.state;\n\n    const {\n      className,\n      onActiveElementChanged,\n      items,\n      cellsPerPage,\n      ref,\n      role,\n      focusZoneComponentRef,\n      listProps = {},\n      ...divProps\n    } = this.props;\n\n    const { onRenderRoot, onRenderPage, ...otherListProps } = listProps;\n\n    const finalOnRenderRoot = onRenderRoot\n      ? composeRenderFunction(onRenderRoot, this._onRenderListRoot)\n      : this._onRenderListRoot;\n    const finalOnRenderPage = onRenderPage\n      ? composeRenderFunction(onRenderPage, this._onRenderPage)\n      : this._onRenderPage;\n\n    return (\n      <FocusZone\n        {...divProps}\n        ref={ref as (element: FocusZone | null) => void}\n        componentRef={focusZoneComponentRef}\n        className={css('ms-TilesList', className)}\n        direction={FocusZoneDirection.bidirectional}\n        onActiveElementChanged={this.props.onActiveElementChanged}\n      >\n        <FocusRects />\n        <List\n          items={cells}\n          role={role}\n          onRenderRoot={finalOnRenderRoot}\n          getPageSpecification={this._getPageSpecification}\n          onRenderPage={finalOnRenderPage}\n          ref={this.listRef}\n          usePageCache={true}\n          {...otherListProps}\n        />\n      </FocusZone>\n    );\n  }\n\n  public scrollToIndex(index: number, mode: ScrollToMode = ScrollToMode.auto): void {\n    if (this.listRef && this.listRef.current) {\n      if (this.state.cells[index].grid.mode === TilesGridMode.none) {\n        // if we are using grid mode none, we reliably know the height of the cell,\n        // so we can implement the measureItem callback.\n        this.listRef.current.scrollToIndex(\n          index,\n          (itemIndex: number) => {\n            const cell = this.state.cells[index];\n            if (cell && cell.desiredHeight !== undefined) {\n              return cell.desiredHeight;\n            }\n            return 0;\n          },\n          mode,\n        );\n      } else {\n        // otherwise, we do not implement the measure item callback,\n        // then the List will just scroll to the nearest page\n        this.listRef.current.scrollToIndex(index, undefined, mode);\n      }\n    }\n  }\n\n  public getTotalListHeight(): number {\n    if (this.listRef && this.listRef.current && this.listRef.current.getTotalListHeight) {\n      return this.listRef.current.getTotalListHeight();\n    }\n    return 0; // Stub\n  }\n\n  private _onRenderCell(item: ITileCell<TItem>, finalSize: ITileSize, column: number): JSX.Element {\n    if (item.grid.mode === TilesGridMode.none) {\n      return (\n        <div role=\"presentation\" className={css(TilesListStyles.header)}>\n          {item.onRender({\n            item: item.content,\n            finalSize: { width: 0, height: 0 },\n            position: {\n              column,\n            },\n          })}\n        </div>\n      );\n    }\n\n    const itemWidthOverHeight = item.aspectRatio;\n    const itemHeightOverWidth = 1 / itemWidthOverHeight;\n\n    return (\n      <div\n        role=\"presentation\"\n        className={css(TilesListStyles.cell)}\n        style={\n          item.grid.mode === TilesGridMode.fillHorizontal\n            ? {\n                height: `${item.grid.minRowHeight}px`,\n              }\n            : {\n                paddingTop: `${(100 * itemHeightOverWidth).toFixed(2)}%`,\n              }\n        }\n      >\n        <div role=\"presentation\" className={css(TilesListStyles.cellContent)}>\n          {item.onRender({\n            item: item.content,\n            finalSize,\n            position: {\n              column,\n            },\n          })}\n        </div>\n      </div>\n    );\n  }\n\n  private _onRenderListRoot = (\n    props: IListOnRenderRootProps<TItem>,\n    defaultRender?: IRenderFunction<IListOnRenderRootProps<TItem>>,\n  ): JSX.Element | null => {\n    const { onRenderRoot } = this.props;\n\n    if (!defaultRender) {\n      return null;\n    }\n\n    const { pages } = props;\n\n    let rowCount = 0;\n    let maxColCount = 0;\n\n    for (const page of pages) {\n      const data = page.data as IPageData<TItem> | undefined;\n\n      if (data) {\n        for (const key of Object.keys(data.rows)) {\n          const rowData = data.rows[Number(key)];\n\n          rowCount++;\n          maxColCount = Math.max(maxColCount, rowData.cellCount);\n        }\n      }\n    }\n\n    const baseOnRenderRoot = (baseProps: ITilesListRootProps<TItem>): JSX.Element | null => {\n      return defaultRender({\n        ...props,\n        divProps: {\n          ...props.divProps,\n          ...baseProps.divProps,\n        },\n        surfaceElement: baseProps.surfaceElement,\n      });\n    };\n\n    const finalOnRenderRoot = onRenderRoot ? composeRenderFunction(onRenderRoot, baseOnRenderRoot) : baseOnRenderRoot;\n\n    return finalOnRenderRoot({\n      surfaceElement: props.surfaceElement,\n      divProps: props.divProps,\n      rowCount: rowCount,\n      columnCount: maxColCount,\n    });\n  };\n\n  /**\n   * Renders a single list page using a flexbox layout.\n   * By default, List provides no special formatting for a list page. For Tiles, the parent element\n   * needs flexbox metadata and padding to support the alignment rules.\n   */\n  private _onRenderPage = (pageProps?: IPageProps, defaultRender?: IRenderFunction<IPageProps>): JSX.Element | null => {\n    if (!pageProps) {\n      return null;\n    }\n\n    const { role, onRenderRow } = this.props;\n\n    const finalOnRenderRow = onRenderRow ? composeRenderFunction(onRenderRow, this._renderRow) : this._renderRow;\n\n    const { page, className: pageClassName, ...divProps } = pageProps;\n\n    const { items } = page;\n\n    const data: IPageData<TItem> = page.data;\n\n    const cells: ITileCell<TItem>[] = items || [];\n\n    const grids: React.ReactNode[] = [];\n\n    const previousCell = this.state.cells[page.startIndex - 1];\n    const nextCell = this.state.cells[page.startIndex + page.itemCount];\n\n    const endIndex = cells.length;\n\n    let currentRow: IRowData | undefined;\n    let currentRowCells = [];\n\n    let shimmerWrapperWidth = 0;\n\n    for (let i = 0; i < endIndex; ) {\n      // For each cell at the start of a grid.\n      const grid = cells[i].grid;\n\n      const { isPlaceholder, maxRowCount } = grid;\n\n      const renderedCells: React.ReactNode[] = [];\n\n      const width = data.pageWidths[page.startIndex + i];\n\n      let rowCount = 0;\n      let isAtMaxRowCount = false;\n      let columnIndex = 0;\n\n      for (; i < endIndex && cells[i].grid === grid; i++) {\n        // For each cell in the current grid.\n        const cell = cells[i];\n\n        const index = page.startIndex + i;\n        const cellAsFirstRow = data.rows[index];\n\n        if (cellAsFirstRow) {\n          if (currentRowCells.length > 0) {\n            renderedCells.push(\n              finalOnRenderRow({\n                cellElements: currentRowCells,\n                divProps: {\n                  className: TilesListStyles.row,\n                  role: 'presentation',\n                },\n              }),\n            );\n            currentRowCells = [];\n          }\n\n          if (cellAsFirstRow !== currentRow) {\n            rowCount++;\n          }\n\n          if (typeof maxRowCount === 'number' && rowCount > maxRowCount) {\n            isAtMaxRowCount = true;\n            break;\n          }\n\n          currentRow = cellAsFirstRow;\n          columnIndex = 0;\n        }\n\n        let finalSize = data.cellSizes[index];\n\n        if (currentRow) {\n          const { scaleFactor, isLastRow, maxScaleFactor: currentRowMaxScaleFactor } = currentRow;\n\n          if (currentRowMaxScaleFactor) {\n            // If the current row has its own max scale factor,\n            // compute final size from the provided value.\n            const finalScaleFactor = Math.min(currentRowMaxScaleFactor, grid.maxScaleFactor);\n\n            finalSize = {\n              width: finalSize.width * finalScaleFactor,\n              height: grid.mode === TilesGridMode.fill ? finalSize.height * finalScaleFactor : grid.minRowHeight,\n            };\n          } else if (\n            (grid.mode === TilesGridMode.fill || grid.mode === TilesGridMode.fillHorizontal) &&\n            (!isLastRow || scaleFactor <= grid.maxScaleFactor)\n          ) {\n            // Compute the final size from the overall max scale factor, if present.\n            const finalScaleFactor = Math.min(grid.maxScaleFactor, scaleFactor);\n\n            finalSize = {\n              width: finalSize.width * finalScaleFactor,\n              height: grid.mode === TilesGridMode.fill ? finalSize.height * finalScaleFactor : grid.minRowHeight,\n            };\n          }\n        }\n\n        const renderedCell = (keyOffset: number = 0): JSX.Element => {\n          return (\n            <div\n              key={`${grid.key}-item-${cell.key}${keyOffset ? '-' + keyOffset : ''}`}\n              data-list-index={index}\n              role={role ? 'presentation' : 'listitem'}\n              className={css('ms-List-cell', this._onGetCellClassName(), {\n                [`ms-TilesList-cell--firstInRow ${TilesListStyles.cellFirstInRow}`]: !!cellAsFirstRow,\n              })}\n              data-automationid=\"ListCell\"\n              style={{\n                ...this._onGetCellStyle(cell, currentRow),\n              }}\n            >\n              {this._onRenderCell(cell, finalSize, columnIndex + keyOffset)}\n            </div>\n          );\n        };\n\n        if (cell.isPlaceholder && grid.mode !== TilesGridMode.none) {\n          const cellsPerRow = Math.floor(width / (grid.spacing + finalSize.width));\n          const totalPlaceholderItems = cellsPerRow * ROWS_OF_PLACEHOLDER_CELLS;\n          shimmerWrapperWidth = cellsPerRow * finalSize.width + grid.spacing * (cellsPerRow - 1);\n          for (let j = 0; j < totalPlaceholderItems; j++) {\n            currentRowCells.push(renderedCell(j));\n          }\n        } else {\n          shimmerWrapperWidth = finalSize.width / 3;\n          currentRowCells.push(renderedCell());\n        }\n\n        columnIndex++;\n      }\n\n      if (isAtMaxRowCount) {\n        for (; i < endIndex && cells[i].grid === grid; i++) {\n          // Consume the rest of the grid.\n        }\n      }\n\n      const isOpenStart = previousCell && previousCell.grid === grid;\n      const isOpenEnd = nextCell && nextCell.grid === grid;\n\n      const margin = grid.spacing / 2;\n\n      if (currentRowCells.length > 0) {\n        renderedCells.push(\n          finalOnRenderRow({\n            cellElements: currentRowCells,\n            divProps: {\n              className: css(TilesListStyles.row, {\n                [TilesListStyles.headerRow]: grid.mode === TilesGridMode.none,\n              }),\n              role: 'presentation',\n            },\n          }),\n        );\n        currentRowCells = [];\n      }\n\n      const finalGrid: JSX.Element = (\n        <div\n          key={grid.key}\n          role=\"presentation\"\n          className={css('ms-TilesList-grid', {\n            [`${TilesListStyles.grid}`]: grid.mode !== TilesGridMode.none,\n            [`${TilesListStyles.shimmeredList}`]: isPlaceholder,\n          })}\n          style={{\n            width: `${width}px`,\n            margin: `${-margin}px`,\n            marginTop: isOpenStart ? '0' : `${grid.marginTop - margin}px`,\n            marginBottom: isOpenEnd ? '0' : `${grid.marginBottom - margin}px`,\n          }}\n        >\n          {renderedCells}\n        </div>\n      );\n\n      grids.push(\n        isPlaceholder ? <Shimmer key={i} customElementsGroup={finalGrid} width={shimmerWrapperWidth} /> : finalGrid,\n      );\n    }\n\n    return (\n      <div role=\"presentation\" {...divProps} className={css(pageClassName, this._onGetPageClassName())}>\n        {grids}\n      </div>\n    );\n  };\n\n  /**\n   * Gets the specification for the list page, which requires pre-calculating the flexbox layout\n   * to determine the set of tiles which fit neatly within a rectangle. Any tiles left dangling\n   * at the end of a page are overflowed into the next page unless they are just before a grid\n   * boundary.\n   */\n  private _getPageSpecification = (\n    startIndex: number,\n    bounds: IRectangle,\n  ): {\n    itemCount: number;\n    data: IPageData<TItem>;\n  } => {\n    if (this._pageSpecificationCache) {\n      if (this._pageSpecificationCache.width !== bounds.width) {\n        this._pageSpecificationCache = undefined;\n      }\n    }\n\n    if (!this._pageSpecificationCache) {\n      this._pageSpecificationCache = {\n        width: bounds.width,\n        byIndex: {},\n      };\n    }\n\n    const pageSpecificationCache = this._pageSpecificationCache;\n\n    if (pageSpecificationCache.byIndex[startIndex]) {\n      // If the page specification has already been calculated, return it.\n      // List recalculates all pages if any input changes, so this memoization\n      // cuts down on calculation of individual pages without changes.\n      return pageSpecificationCache.byIndex[startIndex];\n    }\n\n    const { cells } = this.state;\n    const { cellsPerPage = CELLS_PER_PAGE } = this.props;\n\n    const endIndex = Math.min(cells.length, startIndex + cellsPerPage);\n\n    let rowWidth = 0;\n    let rowStart = 0;\n    let i = startIndex;\n\n    let isAtGridEnd = true;\n\n    const startCells: IPageData<TItem>['rows'] = {};\n    let extraCells: IPageData<TItem>['extraCells'] | undefined;\n    const cellSizes: IPageData<TItem>['cellSizes'] = {};\n    const widths: IPageData<TItem>['pageWidths'] = {};\n\n    for (; i < endIndex; ) {\n      // For each cell at the start of a grid.\n      const grid = cells[i].grid;\n\n      const { maxRowCount } = grid;\n\n      rowWidth = 0;\n      rowStart = i;\n\n      const boundsWidth = bounds.width + grid.spacing;\n\n      widths[i] = boundsWidth;\n\n      let currentRow: IRowData = (startCells[i] = {\n        scaleFactor: 1,\n        cellCount: 0,\n      });\n\n      if (grid.mode === TilesGridMode.none) {\n        // The current \"grid\" just takes up the full width.\n        // No flex calculations necessary.\n        isAtGridEnd = true;\n        cellSizes[i] = {\n          width: bounds.width,\n          height: 0,\n        };\n        currentRow.cellCount++;\n        i++;\n        continue;\n      }\n\n      let rowCount = 0;\n      let isAtMaxRowCount = false;\n\n      for (; i < endIndex && cells[i].grid === grid; i++) {\n        if (typeof maxRowCount === 'number' && rowCount >= maxRowCount) {\n          isAtMaxRowCount = true;\n          break;\n        }\n\n        // For each cell in the current grid.\n        const { aspectRatio } = cells[i];\n\n        const width = aspectRatio * grid.minRowHeight + grid.spacing;\n\n        if (rowWidth + width > boundsWidth) {\n          const totalMargin = grid.spacing * (i - rowStart);\n          currentRow.scaleFactor = (boundsWidth - totalMargin) / (rowWidth - totalMargin);\n        }\n\n        rowWidth += width;\n\n        cellSizes[i] = {\n          // Assign the expected base size of the cell.\n          // Scaling will be handled at render time.\n          width: aspectRatio * grid.minRowHeight,\n          height: grid.minRowHeight,\n        };\n\n        if (rowWidth > boundsWidth) {\n          rowWidth = width;\n          rowStart = i;\n          // Add a marker for a new row, with the default scale factor.\n          currentRow = startCells[i] = {\n            scaleFactor: 1,\n            cellCount: 0,\n          };\n\n          rowCount++;\n        }\n\n        currentRow.cellCount++;\n      }\n\n      if (!cells[i] || cells[i].grid !== grid || isAtMaxRowCount) {\n        // If the next cell is part of a different grid.\n        currentRow.isLastRow = true;\n      } else {\n        isAtGridEnd = false;\n      }\n\n      if (rowWidth < boundsWidth) {\n        const totalMargin = grid.spacing * (i - rowStart);\n        currentRow.scaleFactor = (boundsWidth - totalMargin) / (rowWidth - totalMargin);\n\n        if ((grid.mode === TilesGridMode.fill || grid.mode === TilesGridMode.fillHorizontal) && currentRow.isLastRow) {\n          if (i - rowStart > 0) {\n            // If the grid is in 'fill' mode, and there is underflow in the last row, then by default, flexbox will\n            // scale all widths to the maximum possible, which may cause regularly-sized items to be larger than\n            // those in previous rows.\n            // A way to counter that is to pretend that the last row is actually filled with more items, and calculate\n            // the resulting scale factor. Then pass the new maximum width to flexbox.\n            // The result should be perfectly-aligned final items.\n            // The 'phantom' items are not actually rendered in the list.\n\n            // Project the average tile width across the rest of the row.\n            const width = (rowWidth - totalMargin) / (i - rowStart) + grid.spacing;\n\n            let phantomRowWidth = rowWidth;\n\n            for (let j = i; ; j++) {\n              if (phantomRowWidth + width > boundsWidth) {\n                // The final phantom item has been added, so the row is complete.\n                const phantomTotalMargin = grid.spacing * (j - rowStart);\n                // Set the new scale factor based on the total width including the phantom items.\n                currentRow.maxScaleFactor = (boundsWidth - phantomTotalMargin) / (phantomRowWidth - phantomTotalMargin);\n                break;\n              }\n\n              phantomRowWidth += width;\n            }\n          }\n        }\n      }\n\n      if (\n        !isAtGridEnd &&\n        currentRow.scaleFactor >\n          (grid.mode === TilesGridMode.fill || grid.mode === TilesGridMode.fillHorizontal ? grid.maxScaleFactor : 1)\n      ) {\n        // If the last computed row is not the end of the grid, and the content cannot scale to fit the width,\n        // declare these cells as 'extra' and let them be pushed into the next page.\n        extraCells = cells.slice(rowStart, i);\n      }\n\n      if (isAtMaxRowCount) {\n        while (i < cells.length && cells[i].grid === grid) {\n          // Consume the rest of the cells in the grid if the max row count has been achieved.\n          i++;\n        }\n      }\n    }\n\n    // If there are extra cells, cut off the page so the extra cells will be pushed into the next page.\n    // Otherwise, take all the cells.\n    const itemCount = i - (extraCells ? extraCells.length : 0) - startIndex;\n\n    const pageSpecification: IPageSpecification<TItem> = {\n      itemCount: itemCount,\n      data: {\n        pageWidths: widths,\n        rows: startCells,\n        extraCells: extraCells,\n        cellSizes: cellSizes,\n      },\n    };\n\n    pageSpecificationCache.byIndex[startIndex] = pageSpecification;\n\n    return pageSpecification;\n  };\n\n  private _renderRow: IRenderFunction<ITilesListRowProps<TItem>> = (props: ITilesListRowProps<TItem>): JSX.Element => {\n    const { cellElements, divProps } = props;\n\n    return (\n      <div role=\"presentation\" {...divProps}>\n        {cellElements}\n      </div>\n    );\n  };\n\n  private _onGetCellClassName = (): string => {\n    return TilesListStyles.listCell;\n  };\n\n  private _onGetPageClassName = (): string => {\n    return TilesListStyles.listPage;\n  };\n\n  /**\n   * Get the style to be applied to a single list cell, which will specify the flex behavior\n   * within the flexbox layout.\n   */\n  private _onGetCellStyle = (item: ITileCell<TItem>, currentRow?: IRowData): React.CSSProperties => {\n    const {\n      grid: { mode: gridMode, maxScaleFactor },\n      grid,\n    } = item;\n\n    if (gridMode === TilesGridMode.none) {\n      return {};\n    }\n\n    const itemWidthOverHeight = item.aspectRatio || 1;\n    const margin = grid.spacing / 2;\n    const isFill = gridMode === TilesGridMode.fill || gridMode === TilesGridMode.fillHorizontal;\n    const width = itemWidthOverHeight * grid.minRowHeight;\n\n    let maxWidth: number;\n\n    if (currentRow && currentRow.maxScaleFactor) {\n      // If the row has its own max scale factor, force flexbox to limit at that value.\n      // This typically happens if there is underflow in the final row of a grid.\n      maxWidth = width * Math.min(currentRow.maxScaleFactor, maxScaleFactor);\n    } else if (isFill && (!currentRow || !currentRow.isLastRow || currentRow.scaleFactor <= maxScaleFactor)) {\n      // If the entire grid has a max scale factor, use that limit.\n      maxWidth = width * maxScaleFactor;\n    } else {\n      maxWidth = width;\n    }\n\n    return {\n      flex: isFill ? `${itemWidthOverHeight} ${itemWidthOverHeight} ${width}px` : `0 0 ${width}px`,\n      maxWidth: `${maxWidth}px`,\n      margin: !item.isPlaceholder ? `${margin}px` : 0,\n      borderStyle: item.isPlaceholder ? 'solid' : 'none',\n      borderWidth: item.isPlaceholder ? `${margin}px` : 0,\n    };\n  };\n\n  /**\n   * Flattens the grid and item specifications into a cell list. List will partition the cells into\n   * pages use `getPageSpecification`, so each cell is marked up with metadata to assist the flexbox\n   * algorithm.\n   */\n  private _getCells(items: (ITilesGridSegment<TItem> | ITilesGridItem<TItem>)[]): ITileCell<TItem>[] {\n    const cells: ITileCell<TItem>[] = [];\n\n    for (const item of items) {\n      if (isGridSegment(item)) {\n        // The item is a grid of child items.\n        const {\n          spacing = 0,\n          maxScaleFactor = MAX_TILE_STRETCH,\n          marginBottom = 0,\n          marginTop = 0,\n          minAspectRatio = MIN_ASPECT_RATIO,\n          maxAspectRatio = MAX_ASPECT_RATIO,\n        } = item;\n\n        const grid: ITileGrid = {\n          minRowHeight: item.minRowHeight,\n          spacing: spacing,\n          mode: item.mode,\n          key: `grid-${item.key}`,\n          maxScaleFactor: maxScaleFactor,\n          marginTop: item.isPlaceholder ? 0 : marginTop,\n          marginBottom: item.isPlaceholder ? 0 : marginBottom,\n          isPlaceholder: item.isPlaceholder,\n          maxRowCount: item.maxRowCount,\n        };\n\n        for (const gridItem of item.items) {\n          const { desiredSize, onRender: itemOnRender, onRenderCell } = gridItem;\n\n          const aspectRatio = Math.min(\n            maxAspectRatio,\n            Math.max(minAspectRatio, (desiredSize && desiredSize.width / desiredSize.height) || 1),\n          );\n\n          const onRender =\n            onRenderCell ||\n            ((props: ITilesGridItemCellProps<TItem>) => {\n              if (!itemOnRender) {\n                return null;\n              }\n\n              return itemOnRender(props.item, props.finalSize);\n            });\n\n          cells.push({\n            aspectRatio: aspectRatio,\n            content: gridItem.content,\n            onRender,\n            grid: grid,\n            key: gridItem.key,\n            isPlaceholder: gridItem.isPlaceholder,\n            desiredHeight: desiredSize ? desiredSize.height : undefined,\n          });\n        }\n      } else {\n        const { onRenderCell, onRender: itemOnRender } = item;\n\n        const onRender =\n          onRenderCell ||\n          ((props: ITilesGridItemCellProps<TItem>) => {\n            if (!itemOnRender) {\n              return null;\n            }\n\n            return itemOnRender(props.item, props.finalSize);\n          });\n\n        // The item is not part of the grid, and should take up a whole row.\n        cells.push({\n          aspectRatio: 1,\n          content: item.content,\n          onRender,\n          grid: {\n            minRowHeight: 0,\n            spacing: 0,\n            mode: TilesGridMode.none,\n            key: `grid-header-${item.key}`,\n            maxScaleFactor: 1,\n            marginBottom: 0,\n            marginTop: 0,\n            isPlaceholder: item.isPlaceholder,\n          },\n          key: `header-${item.key}`,\n          isPlaceholder: item.isPlaceholder,\n        });\n      }\n    }\n\n    return cells;\n  }\n}\n\nfunction isGridSegment<TItem>(\n  item: ITilesGridSegment<TItem> | ITilesGridItem<TItem>,\n): item is ITilesGridSegment<TItem> {\n  return !!(item as ITilesGridSegment<TItem>).items;\n}\n"]}