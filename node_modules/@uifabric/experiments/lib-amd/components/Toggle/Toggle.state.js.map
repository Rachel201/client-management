{"version":3,"file":"Toggle.state.js","sourceRoot":"../src/","sources":["components/Toggle/Toggle.state.ts"],"names":[],"mappings":";;;IAIA,4CAA4C;IAE5C,kBAAkB;IACL,QAAA,cAAc,GAA8B,UAAA,KAAK;QAC5D,IAAM,eAAe,GAAG,KAAK,CAAC,MAAM,CAA2B,IAAI,CAAC,CAAC;QAE/D,IAAA;;;UAGJ,EAHK,eAAO,EAAE,kBAGd,CAAC;QAEH,KAAK,CAAC,mBAAmB,CAAC,KAAK,CAAC,YAAY,EAAE,cAAM,OAAA,CAAC;YACnD,KAAK,EAAE;gBACL,eAAe,CAAC,OAAO,IAAI,eAAe,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;YAC7D,CAAC;SACF,CAAC,EAJkD,CAIlD,CAAC,CAAC;QAEI,IAAA,yBAAQ,EAAE,yBAAQ,CAAW;QAErC,IAAM,QAAQ,GAAG,KAAK,CAAC,WAAW,CAChC,UAAC,EAAiC;YAChC,IAAI,CAAC,QAAQ,EAAE;gBACb,wDAAwD;gBACxD,UAAU,CAAC,CAAC,OAAO,CAAC,CAAC;gBAErB,IAAI,QAAQ,EAAE;oBACZ,QAAQ,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC;iBACxB;aACF;QACH,CAAC,EACD,CAAC,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,UAAU,CAAC,CAC1C,CAAC;QAEF,sHAAsH;QACtH,uGAAuG;QACvG,IAAM,SAAS,yCACV,KAAK,KACR,OAAO,SAAA;YACP,eAAe,iBAAA,EACf,OAAO,EAAE,QAAQ,GAClB,CAAC;QAEF,sEAAsE;QACtE,2FAA2F;QAC3F,2EAA2E;QAC3E,8GAA8G;QAC9G,qEAAqE;QACrE,8DAA8D;QAC9D,6GAA6G;QAC7G,SAAS,CAAC,IAAI,GAAG,sCAAyB,CACxC,SAAS,EACT,MAAM,EACN,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS,CAAC,OAAO,CACzD,CAAC;QAEF,OAAO,SAAS,CAAC;IACnB,CAAC,CAAC","sourcesContent":["import * as React from 'react';\nimport { getControlledDerivedProps, useControlledState } from '../../Foundation';\nimport { IToggleComponent, IToggleViewProps } from './Toggle.types';\n\n/* eslint-disable deprecation/deprecation */\n\n/** @deprecated */\nexport const useToggleState: IToggleComponent['state'] = props => {\n  const toggleButtonRef = React.useRef<HTMLButtonElement | null>(null);\n\n  const [checked, setChecked] = useControlledState(props, 'checked', {\n    defaultPropName: 'defaultChecked',\n    defaultPropValue: false,\n  });\n\n  React.useImperativeHandle(props.componentRef, () => ({\n    focus: () => {\n      toggleButtonRef.current && toggleButtonRef.current.focus();\n    },\n  }));\n\n  const { disabled, onChange } = props;\n\n  const _onClick = React.useCallback(\n    (ev: React.MouseEvent<HTMLElement>) => {\n      if (!disabled) {\n        // Only update the state if the user hasn't provided it.\n        setChecked(!checked);\n\n        if (onChange) {\n          onChange(ev, !checked);\n        }\n      }\n    },\n    [checked, disabled, onChange, setChecked],\n  );\n\n  // TODO: can this be structured with helpers to reduce changes for bugs? (overriding controlled props in output, etc.)\n  // TODO: easy ways to minimize unnecessary recreations of viewProps? memoize helper for updating props?\n  const viewProps: IToggleViewProps = {\n    ...props,\n    checked,\n    toggleButtonRef,\n    onClick: _onClick,\n  };\n\n  // Derived state should be performed on otherwise finalized viewProps.\n  // TODO: Uses of propsTransform must be called after viewProps it depends on are finalized.\n  //       Are there any helper ways of doing this to reduce changes of bugs?\n  //       Something that would let state functions safely write whatever they want into viewProps without fear:\n  //         Return array from here including list of controlled props?\n  //         List of controlled props as createComponent option?\n  //         updateViewProps functional arg that takes in partial view props and optional controlled prop list?\n  viewProps.text = getControlledDerivedProps(\n    viewProps,\n    'text',\n    viewProps.checked ? viewProps.onText : viewProps.offText,\n  );\n\n  return viewProps;\n};\n"]}