{"version":3,"file":"ScrollContainer.js","sourceRoot":"../src/","sources":["utilities/scrolling/ScrollContainer.tsx"],"names":[],"mappings":";;;IAuBa,QAAA,2BAA2B,GAAG;QACzC,eAAe,EAAE,SAAS,CAAC,MAAM,CAAC,UAAU;KAC7C,CAAC;IAEF;QAAqC,2CAAsC;QAYzE,yBAAY,KAA4B;YAAxC,YACE,kBAAM,KAAK,CAAC,SAIb;YAVO,gBAAU,GAAuB,EAAE,CAAC;YACpC,sBAAgB,GAAc,EAAE,CAAC;YAyDjC,kBAAY,GAAG,UAAC,OAAuB;gBAC7C,IAAI,OAAO,EAAE;oBACX,KAAI,CAAC,KAAK,GAAG,OAAO,CAAC;oBACrB,KAAI,CAAC,KAAK,EAAE,CAAC;iBACd;YACH,CAAC,CAAC;YAEM,qBAAe,GAAG,UAAC,OAAoC,EAAE,QAA8B;gBAC7F,KAAoB,UAAO,EAAP,mBAAO,EAAP,qBAAO,EAAP,IAAO,EAAE;oBAAxB,IAAM,KAAK,gBAAA;oBACd,IAAK,KAAa,CAAC,cAAc,IAAI,KAAK,CAAC,iBAAiB,GAAG,CAAC,EAAE;wBAChE,mCAAmC;wBACnC,KAAI,CAAC,MAAM,CAAC,qBAAqB,CAAC;4BAChC,IAAM,SAAS,GAAG,KAAI,CAAC,KAAK,CAAC,SAAS,CAAC;4BACvC,KAAuB,UAAe,EAAf,KAAA,KAAI,CAAC,UAAU,EAAf,cAAe,EAAf,IAAe,EAAE;gCAAnC,IAAM,QAAQ,SAAA;gCACjB,QAAQ,CAAC,SAAS,CAAC,CAAC;6BACrB;wBACH,CAAC,CAAC,CAAC;wBAEH,2CAA2C;wBAC3C,OAAO;qBACR;iBACF;YACH,CAAC,CAAC;YAqCM,eAAS,GAAG;gBAClB,IAAM,SAAS,GAAG,KAAI,CAAC,KAAK,CAAC,SAAS,CAAC;gBAEvC,KAAuB,UAAe,EAAf,KAAA,KAAI,CAAC,UAAU,EAAf,cAAe,EAAf,IAAe,EAAE;oBAAnC,IAAM,QAAQ,SAAA;oBACjB,QAAQ,CAAC,SAAS,CAAC,CAAC;iBACrB;YACH,CAAC,CAAC;YAnHA,KAAI,CAAC,MAAM,GAAG,IAAI,iBAAK,CAAC,KAAI,CAAC,CAAC;YAC9B,kCAAsB,CAAC,KAAI,CAAC,CAAC;;QAC/B,CAAC;QAEM,yCAAe,GAAtB;YACE,OAAO;gBACL,eAAe,EAAE,IAAI;aACtB,CAAC;QACJ,CAAC;QAEM,iCAAO,GAAd,UAAe,OAAgB;YAC7B,IAAI,IAAI,CAAC,SAAS,EAAE;gBAClB,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;aACjC;iBAAM;gBACL,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;aACrC;QACH,CAAC;QAEM,mCAAS,GAAhB,UAAiB,OAAgB;YAC/B,IAAI,IAAI,CAAC,SAAS,EAAE;gBAClB,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC;aACnC;QACH,CAAC;QAEM,iDAAuB,GAA9B,UAA+B,QAA0B;YACvD,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;QACjC,CAAC;QAEM,gCAAM,GAAb;YACQ,IAAA,eAAoC,EAAlC,sBAAQ,EAAE,wBAAwB,CAAC;YAE3C,OAAO,CACL,6BACE,SAAS,EAAE,eAAG,CAAC,oBAAoB,EAAE,qBAAqB,CAAC,IAAI,EAAE,SAAS,CAAC,wBACvD,IAAI,EACxB,GAAG,EAAE,IAAI,CAAC,YAAY,IAErB,QAAuB,CACpB,CACP,CAAC;QACJ,CAAC;QAEM,8CAAoB,GAA3B;YACE,IAAI,IAAI,CAAC,SAAS,EAAE;gBAClB,IAAI,CAAC,SAAS,CAAC,UAAU,EAAE,CAAC;aAC7B;YAED,IAAI,CAAC,MAAM,CAAC,OAAO,EAAE,CAAC;QACxB,CAAC;QA0BO,+BAAK,GAAb;YACE,IAAI,OAAO,oBAAoB,KAAK,WAAW,EAAE;gBAC/C,IAAM,SAAS,GAAa,EAAE,CAAC;gBAC/B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,EAAE,EAAE,CAAC,EAAE;oBAC5B,SAAS,CAAC,IAAI,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC;iBAC3B;gBAED,IAAI,CAAC,SAAS,GAAG,IAAI,oBAAoB,CACvC,IAAI,CAAC,eAA+C,EACpD;oBACE,IAAI,EAAE,IAAI,CAAC,KAAK;oBAChB,SAAS,WAAA;iBACkB,CAC9B,CAAC;gBAEF,yFAAyF;gBACzF,IAAI,IAAI,CAAC,gBAAgB,CAAC,MAAM,GAAG,CAAC,EAAE;oBACpC,KAA6B,UAAqB,EAArB,KAAA,IAAI,CAAC,gBAAgB,EAArB,cAAqB,EAArB,IAAqB,EAAE;wBAA/C,IAAM,cAAc,SAAA;wBACvB,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC;qBACxC;oBAED,IAAI,CAAC,gBAAgB,GAAG,EAAE,CAAC;iBAC5B;aACF;iBAAM;gBACG,IAAA,oDAAmB,CAAgB;gBAC3C,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,SAAS,EAAE,mBAAmB,CAAC,CAAC;gBAE3E,oGAAoG;gBACpG,6EAA6E;gBAC7E,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,QAAQ,EAAE,IAAI,CAAC,SAAS,EAAE;oBACpD,OAAO,EAAE,IAAI;iBACP,CAAC,CAAC;aACX;QACH,CAAC;QAzHa,iCAAiB,GAAuC,mCAA2B,CAAC;QAkIpG,sBAAC;KAAA,AAnID,CAAqC,KAAK,CAAC,SAAS,GAmInD;IAnIY,0CAAe","sourcesContent":["import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { IScrollContainerProps } from './ScrollContainer.types';\nimport { css, Async, initializeComponentRef } from 'office-ui-fabric-react/lib/Utilities';\n\nimport * as ScrollContainerStyles from './ScrollContainer.scss';\n\nexport interface IVisibleCallback {\n  (scrollTop: number): void;\n}\n\nexport interface IScrollContainer {\n  observe(element: Element): void;\n\n  unobserve(element: Element): void;\n\n  registerVisibleCallback(callback: IVisibleCallback): void;\n}\n\nexport interface IScrollContainerContext {\n  scrollContainer: IScrollContainer;\n}\n\nexport const ScrollContainerContextTypes = {\n  scrollContainer: PropTypes.object.isRequired,\n};\n\nexport class ScrollContainer extends React.Component<IScrollContainerProps> implements IScrollContainer {\n  public static childContextTypes: typeof ScrollContainerContextTypes = ScrollContainerContextTypes;\n\n  private _observer: IntersectionObserver;\n\n  private _root: HTMLDivElement;\n\n  private _callbacks: IVisibleCallback[] = [];\n  private _pendingElements: Element[] = [];\n\n  private _async: Async;\n\n  constructor(props: IScrollContainerProps) {\n    super(props);\n\n    this._async = new Async(this);\n    initializeComponentRef(this);\n  }\n\n  public getChildContext(): IScrollContainerContext {\n    return {\n      scrollContainer: this,\n    };\n  }\n\n  public observe(element: Element): void {\n    if (this._observer) {\n      this._observer.observe(element);\n    } else {\n      this._pendingElements.push(element);\n    }\n  }\n\n  public unobserve(element: Element): void {\n    if (this._observer) {\n      this._observer.unobserve(element);\n    }\n  }\n\n  public registerVisibleCallback(callback: IVisibleCallback): void {\n    this._callbacks.push(callback);\n  }\n\n  public render(): JSX.Element {\n    const { children, className } = this.props;\n\n    return (\n      <div\n        className={css('ms-ScrollContainer', ScrollContainerStyles.root, className)}\n        data-is-scrollable={true}\n        ref={this._resolveRoot}\n      >\n        {children as JSX.Element}\n      </div>\n    );\n  }\n\n  public componentWillUnmount(): void {\n    if (this._observer) {\n      this._observer.disconnect();\n    }\n\n    this._async.dispose();\n  }\n\n  private _resolveRoot = (element: HTMLDivElement): void => {\n    if (element) {\n      this._root = element;\n      this._init();\n    }\n  };\n\n  private _onIntersection = (entries: IntersectionObserverEntry[], observer: IntersectionObserver): void => {\n    for (const entry of entries) {\n      if ((entry as any).isIntersecting || entry.intersectionRatio > 0) {\n        // Schedule callbacks on next frame\n        this._async.requestAnimationFrame(() => {\n          const scrollTop = this._root.scrollTop;\n          for (const callback of this._callbacks) {\n            callback(scrollTop);\n          }\n        });\n\n        // Only need to call callbacks for on entry\n        return;\n      }\n    }\n  };\n\n  private _init(): void {\n    if (typeof IntersectionObserver !== 'undefined') {\n      const threshold: number[] = [];\n      for (let i = 0; i < 100; ++i) {\n        threshold.push(i / 100.0);\n      }\n\n      this._observer = new IntersectionObserver(\n        this._onIntersection as IntersectionObserverCallback,\n        {\n          root: this._root,\n          threshold,\n        } as IntersectionObserverInit,\n      );\n\n      // If there were attempts to observe elements before the observer was ready, add them now\n      if (this._pendingElements.length > 0) {\n        for (const pendingElement of this._pendingElements) {\n          this._observer.observe(pendingElement);\n        }\n\n        this._pendingElements = [];\n      }\n    } else {\n      const { scrollDebounceDelay } = this.props;\n      this._onScroll = this._async.debounce(this._onScroll, scrollDebounceDelay);\n\n      // No intersection observer, rely on scroll event. Note: not all browsers support options, but since\n      // we don't need capture, we can pass it and have it ignored if not supported\n      this._root.addEventListener('scroll', this._onScroll, {\n        passive: true,\n      } as any);\n    }\n  }\n\n  private _onScroll = (): void => {\n    const scrollTop = this._root.scrollTop;\n\n    for (const callback of this._callbacks) {\n      callback(scrollTop);\n    }\n  };\n}\n"]}