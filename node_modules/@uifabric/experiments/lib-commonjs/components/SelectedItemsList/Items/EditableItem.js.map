{"version":3,"file":"EditableItem.js","sourceRoot":"../src/","sources":["components/SelectedItemsList/Items/EditableItem.tsx"],"names":[],"mappings":";;;AAAA,6BAA+B;AAqD/B,yFAAyF;AAC5E,QAAA,YAAY,GAAG,UAAoB,iBAAuC;IACrF,OAAO,KAAK,CAAC,IAAI,CAAC,UAAC,iBAAwC;QACjD,IAAA,6CAAY,EAAE,qDAAgB,EAAE,yDAAkB,EAAE,yDAAkB,EAAE,mCAAO,CAAuB;QACtG,IAAA,6CAAY,EAAE,6BAAI,EAAE,+BAAK,CAAuB;QAExD,IAAM,SAAS,GAAG,YAAY,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAC5C,IAAM,aAAa,GAAG,iBAAiB,CAAC,aAAa,CAAC;QACtD,IAAM,oBAAoB,GAAG,iBAAiB,CAAC,oBAAoB,CAAC;QAEpE,IAAM,SAAS,GAAG,KAAK,CAAC,WAAW,CAAC,cAAM,OAAA,gBAAgB,CAAC,IAAI,EAAE,KAAK,CAAC,EAA7B,CAA6B,EAAE,CAAC,KAAK,EAAE,IAAI,EAAE,gBAAgB,CAAC,CAAC,CAAC;QAE1G,IAAM,iBAAiB,GAAG,KAAK,CAAC,WAAW,CACzC,UAAC,QAAW,EAAE,OAAU;;YACtB,MAAA,YAAY,0CAAG,OAAO,EAAE,KAAK,EAAE;YAC/B,kBAAkB,CAAC,IAAI,EAAE,KAAK,CAAC,CAAC;QAClC,CAAC,EACD,CAAC,KAAK,EAAE,IAAI,EAAE,kBAAkB,EAAE,YAAY,CAAC,CAChD,CAAC;QAEF,IAAM,SAAS,GAAG,KAAK,CAAC,WAAW,CAAC;;YAClC,MAAA,kBAAkB,0CAAG,IAAI,EAAE,KAAK,EAAE;QACpC,CAAC,EAAE,CAAC,KAAK,EAAE,IAAI,EAAE,kBAAkB,CAAC,CAAC,CAAC;QAEtC,IAAM,aAAa,GAAG,KAAK,CAAC,WAAW,CACrC,UAAC,EAAiC;;YAChC,MAAA,OAAO,0CAAG,EAAE,EAAE,IAAI,EAAE,KAAK,EAAE;QAC7B,CAAC,EACD,CAAC,KAAK,EAAE,IAAI,EAAE,OAAO,CAAC,CACvB,CAAC;QAEF,OAAO,SAAS,CAAC,CAAC,CAAC,CACjB,oBAAC,oBAAoB,IACnB,IAAI,EAAE,iBAAiB,CAAC,IAAI,EAC5B,iBAAiB,EAAE,iBAAiB,EACpC,SAAS,EAAE,SAAS,EACpB,iBAAiB,EAAE,iBAAiB,CAAC,iBAAiB,GACtD,CACH,CAAC,CAAC,CAAC,CACF,oBAAC,aAAa,uBAAK,iBAAiB,IAAE,SAAS,EAAE,SAAS,EAAE,OAAO,EAAE,aAAa,IAAI,CACvF,CAAC;IACJ,CAAC,CAAC,CAAC;AACL,CAAC,CAAC","sourcesContent":["import * as React from 'react';\nimport { ISelectedItemProps } from '../SelectedItemsList.types';\nimport { ItemCanDispatchTrigger, Item } from './ItemTrigger.types';\n\nexport type EditingItemComponentProps<T> = {\n  item: T;\n  onEditingComplete: (oldItem: T, newItem: T) => void;\n  onDismiss?: () => void;\n  createGenericItem?: (input: string) => T;\n};\n\n/**\n * Parameters to the EditingItem higher-order component\n */\nexport type EditableItemProps<T> = {\n  /**\n   * Component to render when item is in normal state\n   */\n  itemComponent: ItemCanDispatchTrigger<T>;\n\n  /**\n   * Component to render when item is in editing state\n   */\n  editingItemComponent: React.ComponentType<EditingItemComponentProps<T>>;\n\n  /**\n   * Returns editing state (boolean) of the item\n   */\n  getIsEditing: (item: T, index: number) => boolean;\n\n  /**\n   * Callback when editing should be started. The controlling component should ensure\n   * the item is marked as being edited\n   */\n  onEditingStarted: (item: T, index: number) => void;\n\n  /**\n   * Callback when editing is finished. The controlling component should ensure\n   * the item is marked as being not edited\n   */\n  onEditingCompleted: (item: T, index: number) => void;\n\n  /**\n   * Callback when editing is cancelled/dismissed\n   */\n  onEditingDismissed?: (item: T, index: number) => void;\n\n  /**\n   * Callback for a click on the normal state item component\n   */\n  onClick?: (ev: React.MouseEvent<HTMLElement>, item: T, index: number) => void;\n};\n\n// `extends unknown` to trick the parser into parsing as a type decl instead of a jsx tag\nexport const EditableItem = <T extends unknown>(editableItemProps: EditableItemProps<T>): Item<T> => {\n  return React.memo((selectedItemProps: ISelectedItemProps<T>) => {\n    const { getIsEditing, onEditingStarted, onEditingCompleted, onEditingDismissed, onClick } = editableItemProps;\n    const { onItemChange, item, index } = selectedItemProps;\n\n    const isEditing = getIsEditing(item, index);\n    const ItemComponent = editableItemProps.itemComponent;\n    const EditingItemComponent = editableItemProps.editingItemComponent;\n\n    const onTrigger = React.useCallback(() => onEditingStarted(item, index), [index, item, onEditingStarted]);\n\n    const onEditingComplete = React.useCallback(\n      (_oldItem: T, newItem: T) => {\n        onItemChange?.(newItem, index);\n        onEditingCompleted(item, index);\n      },\n      [index, item, onEditingCompleted, onItemChange],\n    );\n\n    const onDismiss = React.useCallback(() => {\n      onEditingDismissed?.(item, index);\n    }, [index, item, onEditingDismissed]);\n\n    const onItemClicked = React.useCallback(\n      (ev: React.MouseEvent<HTMLElement>) => {\n        onClick?.(ev, item, index);\n      },\n      [index, item, onClick],\n    );\n\n    return isEditing ? (\n      <EditingItemComponent\n        item={selectedItemProps.item}\n        onEditingComplete={onEditingComplete}\n        onDismiss={onDismiss}\n        createGenericItem={selectedItemProps.createGenericItem}\n      />\n    ) : (\n      <ItemComponent {...selectedItemProps} onTrigger={onTrigger} onClick={onItemClicked} />\n    );\n  });\n};\n"]}