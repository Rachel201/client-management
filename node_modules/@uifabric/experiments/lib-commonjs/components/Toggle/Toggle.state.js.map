{"version":3,"file":"Toggle.state.js","sourceRoot":"../src/","sources":["components/Toggle/Toggle.state.ts"],"names":[],"mappings":";;;AAAA,6BAA+B;AAC/B,+CAAiF;AAGjF,4CAA4C;AAE5C,kBAAkB;AACL,QAAA,cAAc,GAA8B,UAAA,KAAK;IAC5D,IAAM,eAAe,GAAG,KAAK,CAAC,MAAM,CAA2B,IAAI,CAAC,CAAC;IAE/D,IAAA;;;MAGJ,EAHK,eAAO,EAAE,kBAGd,CAAC;IAEH,KAAK,CAAC,mBAAmB,CAAC,KAAK,CAAC,YAAY,EAAE,cAAM,OAAA,CAAC;QACnD,KAAK,EAAE;YACL,eAAe,CAAC,OAAO,IAAI,eAAe,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;QAC7D,CAAC;KACF,CAAC,EAJkD,CAIlD,CAAC,CAAC;IAEI,IAAA,yBAAQ,EAAE,yBAAQ,CAAW;IAErC,IAAM,QAAQ,GAAG,KAAK,CAAC,WAAW,CAChC,UAAC,EAAiC;QAChC,IAAI,CAAC,QAAQ,EAAE;YACb,wDAAwD;YACxD,UAAU,CAAC,CAAC,OAAO,CAAC,CAAC;YAErB,IAAI,QAAQ,EAAE;gBACZ,QAAQ,CAAC,EAAE,EAAE,CAAC,OAAO,CAAC,CAAC;aACxB;SACF;IACH,CAAC,EACD,CAAC,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,UAAU,CAAC,CAC1C,CAAC;IAEF,sHAAsH;IACtH,uGAAuG;IACvG,IAAM,SAAS,yCACV,KAAK,KACR,OAAO,SAAA;QACP,eAAe,iBAAA,EACf,OAAO,EAAE,QAAQ,GAClB,CAAC;IAEF,sEAAsE;IACtE,2FAA2F;IAC3F,2EAA2E;IAC3E,8GAA8G;IAC9G,qEAAqE;IACrE,8DAA8D;IAC9D,6GAA6G;IAC7G,SAAS,CAAC,IAAI,GAAG,sCAAyB,CACxC,SAAS,EACT,MAAM,EACN,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,SAAS,CAAC,OAAO,CACzD,CAAC;IAEF,OAAO,SAAS,CAAC;AACnB,CAAC,CAAC","sourcesContent":["import * as React from 'react';\nimport { getControlledDerivedProps, useControlledState } from '../../Foundation';\nimport { IToggleComponent, IToggleViewProps } from './Toggle.types';\n\n/* eslint-disable deprecation/deprecation */\n\n/** @deprecated */\nexport const useToggleState: IToggleComponent['state'] = props => {\n  const toggleButtonRef = React.useRef<HTMLButtonElement | null>(null);\n\n  const [checked, setChecked] = useControlledState(props, 'checked', {\n    defaultPropName: 'defaultChecked',\n    defaultPropValue: false,\n  });\n\n  React.useImperativeHandle(props.componentRef, () => ({\n    focus: () => {\n      toggleButtonRef.current && toggleButtonRef.current.focus();\n    },\n  }));\n\n  const { disabled, onChange } = props;\n\n  const _onClick = React.useCallback(\n    (ev: React.MouseEvent<HTMLElement>) => {\n      if (!disabled) {\n        // Only update the state if the user hasn't provided it.\n        setChecked(!checked);\n\n        if (onChange) {\n          onChange(ev, !checked);\n        }\n      }\n    },\n    [checked, disabled, onChange, setChecked],\n  );\n\n  // TODO: can this be structured with helpers to reduce changes for bugs? (overriding controlled props in output, etc.)\n  // TODO: easy ways to minimize unnecessary recreations of viewProps? memoize helper for updating props?\n  const viewProps: IToggleViewProps = {\n    ...props,\n    checked,\n    toggleButtonRef,\n    onClick: _onClick,\n  };\n\n  // Derived state should be performed on otherwise finalized viewProps.\n  // TODO: Uses of propsTransform must be called after viewProps it depends on are finalized.\n  //       Are there any helper ways of doing this to reduce changes of bugs?\n  //       Something that would let state functions safely write whatever they want into viewProps without fear:\n  //         Return array from here including list of controlled props?\n  //         List of controlled props as createComponent option?\n  //         updateViewProps functional arg that takes in partial view props and optional controlled prop list?\n  viewProps.text = getControlledDerivedProps(\n    viewProps,\n    'text',\n    viewProps.checked ? viewProps.onText : viewProps.offText,\n  );\n\n  return viewProps;\n};\n"]}