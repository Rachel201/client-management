{"version":3,"file":"ScrollContainer.js","sourceRoot":"../src/","sources":["utilities/scrolling/ScrollContainer.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { IScrollContainerProps } from './ScrollContainer.types';\nimport { css, Async, initializeComponentRef } from 'office-ui-fabric-react/lib/Utilities';\n\nimport * as ScrollContainerStyles from './ScrollContainer.scss';\n\nexport interface IVisibleCallback {\n  (scrollTop: number): void;\n}\n\nexport interface IScrollContainer {\n  observe(element: Element): void;\n\n  unobserve(element: Element): void;\n\n  registerVisibleCallback(callback: IVisibleCallback): void;\n}\n\nexport interface IScrollContainerContext {\n  scrollContainer: IScrollContainer;\n}\n\nexport const ScrollContainerContextTypes = {\n  scrollContainer: PropTypes.object.isRequired,\n};\n\nexport class ScrollContainer extends React.Component<IScrollContainerProps> implements IScrollContainer {\n  public static childContextTypes: typeof ScrollContainerContextTypes = ScrollContainerContextTypes;\n\n  private _observer: IntersectionObserver;\n\n  private _root: HTMLDivElement;\n\n  private _callbacks: IVisibleCallback[] = [];\n  private _pendingElements: Element[] = [];\n\n  private _async: Async;\n\n  constructor(props: IScrollContainerProps) {\n    super(props);\n\n    this._async = new Async(this);\n    initializeComponentRef(this);\n  }\n\n  public getChildContext(): IScrollContainerContext {\n    return {\n      scrollContainer: this,\n    };\n  }\n\n  public observe(element: Element): void {\n    if (this._observer) {\n      this._observer.observe(element);\n    } else {\n      this._pendingElements.push(element);\n    }\n  }\n\n  public unobserve(element: Element): void {\n    if (this._observer) {\n      this._observer.unobserve(element);\n    }\n  }\n\n  public registerVisibleCallback(callback: IVisibleCallback): void {\n    this._callbacks.push(callback);\n  }\n\n  public render(): JSX.Element {\n    const { children, className } = this.props;\n\n    return (\n      <div\n        className={css('ms-ScrollContainer', ScrollContainerStyles.root, className)}\n        data-is-scrollable={true}\n        ref={this._resolveRoot}\n      >\n        {children as JSX.Element}\n      </div>\n    );\n  }\n\n  public componentWillUnmount(): void {\n    if (this._observer) {\n      this._observer.disconnect();\n    }\n\n    this._async.dispose();\n  }\n\n  private _resolveRoot = (element: HTMLDivElement): void => {\n    if (element) {\n      this._root = element;\n      this._init();\n    }\n  };\n\n  private _onIntersection = (entries: IntersectionObserverEntry[], observer: IntersectionObserver): void => {\n    for (const entry of entries) {\n      if ((entry as any).isIntersecting || entry.intersectionRatio > 0) {\n        // Schedule callbacks on next frame\n        this._async.requestAnimationFrame(() => {\n          const scrollTop = this._root.scrollTop;\n          for (const callback of this._callbacks) {\n            callback(scrollTop);\n          }\n        });\n\n        // Only need to call callbacks for on entry\n        return;\n      }\n    }\n  };\n\n  private _init(): void {\n    if (typeof IntersectionObserver !== 'undefined') {\n      const threshold: number[] = [];\n      for (let i = 0; i < 100; ++i) {\n        threshold.push(i / 100.0);\n      }\n\n      this._observer = new IntersectionObserver(\n        this._onIntersection as IntersectionObserverCallback,\n        {\n          root: this._root,\n          threshold,\n        } as IntersectionObserverInit,\n      );\n\n      // If there were attempts to observe elements before the observer was ready, add them now\n      if (this._pendingElements.length > 0) {\n        for (const pendingElement of this._pendingElements) {\n          this._observer.observe(pendingElement);\n        }\n\n        this._pendingElements = [];\n      }\n    } else {\n      const { scrollDebounceDelay } = this.props;\n      this._onScroll = this._async.debounce(this._onScroll, scrollDebounceDelay);\n\n      // No intersection observer, rely on scroll event. Note: not all browsers support options, but since\n      // we don't need capture, we can pass it and have it ignored if not supported\n      this._root.addEventListener('scroll', this._onScroll, {\n        passive: true,\n      } as any);\n    }\n  }\n\n  private _onScroll = (): void => {\n    const scrollTop = this._root.scrollTop;\n\n    for (const callback of this._callbacks) {\n      callback(scrollTop);\n    }\n  };\n}\n"]}