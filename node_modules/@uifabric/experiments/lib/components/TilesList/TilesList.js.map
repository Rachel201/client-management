{"version":3,"file":"TilesList.js","sourceRoot":"../src/","sources":["components/TilesList/TilesList.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport {\n  ITilesListProps,\n  ITilesGridItem,\n  ITilesGridSegment,\n  TilesGridMode,\n  ITileSize,\n  ITilesGridItemCellProps,\n  ITilesListRowProps,\n  ITilesListRootProps,\n} from './TilesList.types';\nimport { List, IPageProps, ScrollToMode, IListOnRenderRootProps } from 'office-ui-fabric-react/lib/List';\nimport { FocusZone, FocusZoneDirection } from 'office-ui-fabric-react/lib/FocusZone';\nimport {\n  css,\n  IRenderFunction,\n  IRectangle,\n  FocusRects,\n  composeRenderFunction,\n} from 'office-ui-fabric-react/lib/Utilities';\nimport * as TilesListStylesModule from './TilesList.scss';\nimport { Shimmer } from 'office-ui-fabric-react/lib/Shimmer';\n\nconst TilesListStyles: any = TilesListStylesModule;\n\nconst MAX_TILE_STRETCH = 1.5;\nconst CELLS_PER_PAGE = 100;\nconst MIN_ASPECT_RATIO = 0.5;\nconst MAX_ASPECT_RATIO = 3;\n\nconst ROWS_OF_PLACEHOLDER_CELLS = 3;\n\nexport interface ITilesListState<TItem> {\n  cells: ITileCell<TItem>[];\n}\n\n/**\n * @internal\n */\nexport interface ITileGrid {\n  minRowHeight: number;\n  mode: TilesGridMode;\n  spacing: number;\n  maxScaleFactor: number;\n  marginTop: number;\n  marginBottom: number;\n  key: string;\n  isPlaceholder?: boolean;\n  maxRowCount?: number;\n}\n\n/**\n * @internal\n */\nexport interface ITileCell<TItem> {\n  key: string;\n  content: TItem;\n  aspectRatio: number;\n  grid: ITileGrid;\n  isPlaceholder?: boolean;\n  desiredHeight?: number;\n  onRender(props: {\n    item: TItem;\n    finalSize: {\n      width: number;\n      height: number;\n    };\n    position: {\n      column: number;\n    };\n  }): React.ReactNode;\n}\n\ninterface IRowData {\n  scaleFactor: number;\n  cellCount: number;\n  isLastRow?: boolean;\n  maxScaleFactor?: number;\n}\n\ninterface IPageData<TItem> {\n  pageWidths: {\n    [index: number]: number;\n  };\n  rows: {\n    [index: number]: IRowData;\n  };\n  cellSizes: {\n    [index: number]: ITileSize;\n  };\n  extraCells: ITileCell<TItem>[] | undefined;\n}\n\ninterface IPageSpecification<TItem> {\n  itemCount: number;\n  data: IPageData<TItem>;\n}\n\ninterface IPageSpecificationCache<TItem> {\n  byIndex: {\n    [index: number]: IPageSpecification<TItem>;\n  };\n  width: number;\n}\n\n/**\n * Component which renders a virtualized flexbox list of 'tiles', which have arbitrary width and height\n * and which support scaling to fill rows when needed.\n */\nexport class TilesList<TItem> extends React.Component<ITilesListProps<TItem>, ITilesListState<TItem>> {\n  private _pageSpecificationCache: IPageSpecificationCache<TItem> | undefined;\n  private listRef: React.RefObject<List>;\n\n  constructor(props: ITilesListProps<TItem>, context: any) {\n    super(props, context);\n\n    this.listRef = React.createRef();\n\n    this.state = {\n      cells: this._getCells(props.items),\n    };\n  }\n\n  public UNSAFE_componentWillReceiveProps(nextProps: ITilesListProps<TItem>): void {\n    if (nextProps.items !== this.props.items) {\n      this.setState({\n        cells: this._getCells(nextProps.items),\n      });\n    }\n  }\n\n  public UNSAFE_componentWillUpdate(nextProps: ITilesListProps<TItem>, nextState: ITilesListState<TItem>): void {\n    if (nextState.cells !== this.state.cells) {\n      this._pageSpecificationCache = undefined;\n    }\n  }\n\n  public render(): JSX.Element {\n    const { cells } = this.state;\n\n    const {\n      className,\n      onActiveElementChanged,\n      items,\n      cellsPerPage,\n      ref,\n      role,\n      focusZoneComponentRef,\n      listProps = {},\n      ...divProps\n    } = this.props;\n\n    const { onRenderRoot, onRenderPage, ...otherListProps } = listProps;\n\n    const finalOnRenderRoot = onRenderRoot\n      ? composeRenderFunction(onRenderRoot, this._onRenderListRoot)\n      : this._onRenderListRoot;\n    const finalOnRenderPage = onRenderPage\n      ? composeRenderFunction(onRenderPage, this._onRenderPage)\n      : this._onRenderPage;\n\n    return (\n      <FocusZone\n        {...divProps}\n        ref={ref as (element: FocusZone | null) => void}\n        componentRef={focusZoneComponentRef}\n        className={css('ms-TilesList', className)}\n        direction={FocusZoneDirection.bidirectional}\n        onActiveElementChanged={this.props.onActiveElementChanged}\n      >\n        <FocusRects />\n        <List\n          items={cells}\n          role={role}\n          onRenderRoot={finalOnRenderRoot}\n          getPageSpecification={this._getPageSpecification}\n          onRenderPage={finalOnRenderPage}\n          ref={this.listRef}\n          usePageCache={true}\n          {...otherListProps}\n        />\n      </FocusZone>\n    );\n  }\n\n  public scrollToIndex(index: number, mode: ScrollToMode = ScrollToMode.auto): void {\n    if (this.listRef && this.listRef.current) {\n      if (this.state.cells[index].grid.mode === TilesGridMode.none) {\n        // if we are using grid mode none, we reliably know the height of the cell,\n        // so we can implement the measureItem callback.\n        this.listRef.current.scrollToIndex(\n          index,\n          (itemIndex: number) => {\n            const cell = this.state.cells[index];\n            if (cell && cell.desiredHeight !== undefined) {\n              return cell.desiredHeight;\n            }\n            return 0;\n          },\n          mode,\n        );\n      } else {\n        // otherwise, we do not implement the measure item callback,\n        // then the List will just scroll to the nearest page\n        this.listRef.current.scrollToIndex(index, undefined, mode);\n      }\n    }\n  }\n\n  public getTotalListHeight(): number {\n    if (this.listRef && this.listRef.current && this.listRef.current.getTotalListHeight) {\n      return this.listRef.current.getTotalListHeight();\n    }\n    return 0; // Stub\n  }\n\n  private _onRenderCell(item: ITileCell<TItem>, finalSize: ITileSize, column: number): JSX.Element {\n    if (item.grid.mode === TilesGridMode.none) {\n      return (\n        <div role=\"presentation\" className={css(TilesListStyles.header)}>\n          {item.onRender({\n            item: item.content,\n            finalSize: { width: 0, height: 0 },\n            position: {\n              column,\n            },\n          })}\n        </div>\n      );\n    }\n\n    const itemWidthOverHeight = item.aspectRatio;\n    const itemHeightOverWidth = 1 / itemWidthOverHeight;\n\n    return (\n      <div\n        role=\"presentation\"\n        className={css(TilesListStyles.cell)}\n        style={\n          item.grid.mode === TilesGridMode.fillHorizontal\n            ? {\n                height: `${item.grid.minRowHeight}px`,\n              }\n            : {\n                paddingTop: `${(100 * itemHeightOverWidth).toFixed(2)}%`,\n              }\n        }\n      >\n        <div role=\"presentation\" className={css(TilesListStyles.cellContent)}>\n          {item.onRender({\n            item: item.content,\n            finalSize,\n            position: {\n              column,\n            },\n          })}\n        </div>\n      </div>\n    );\n  }\n\n  private _onRenderListRoot = (\n    props: IListOnRenderRootProps<TItem>,\n    defaultRender?: IRenderFunction<IListOnRenderRootProps<TItem>>,\n  ): JSX.Element | null => {\n    const { onRenderRoot } = this.props;\n\n    if (!defaultRender) {\n      return null;\n    }\n\n    const { pages } = props;\n\n    let rowCount = 0;\n    let maxColCount = 0;\n\n    for (const page of pages) {\n      const data = page.data as IPageData<TItem> | undefined;\n\n      if (data) {\n        for (const key of Object.keys(data.rows)) {\n          const rowData = data.rows[Number(key)];\n\n          rowCount++;\n          maxColCount = Math.max(maxColCount, rowData.cellCount);\n        }\n      }\n    }\n\n    const baseOnRenderRoot = (baseProps: ITilesListRootProps<TItem>): JSX.Element | null => {\n      return defaultRender({\n        ...props,\n        divProps: {\n          ...props.divProps,\n          ...baseProps.divProps,\n        },\n        surfaceElement: baseProps.surfaceElement,\n      });\n    };\n\n    const finalOnRenderRoot = onRenderRoot ? composeRenderFunction(onRenderRoot, baseOnRenderRoot) : baseOnRenderRoot;\n\n    return finalOnRenderRoot({\n      surfaceElement: props.surfaceElement,\n      divProps: props.divProps,\n      rowCount: rowCount,\n      columnCount: maxColCount,\n    });\n  };\n\n  /**\n   * Renders a single list page using a flexbox layout.\n   * By default, List provides no special formatting for a list page. For Tiles, the parent element\n   * needs flexbox metadata and padding to support the alignment rules.\n   */\n  private _onRenderPage = (pageProps?: IPageProps, defaultRender?: IRenderFunction<IPageProps>): JSX.Element | null => {\n    if (!pageProps) {\n      return null;\n    }\n\n    const { role, onRenderRow } = this.props;\n\n    const finalOnRenderRow = onRenderRow ? composeRenderFunction(onRenderRow, this._renderRow) : this._renderRow;\n\n    const { page, className: pageClassName, ...divProps } = pageProps;\n\n    const { items } = page;\n\n    const data: IPageData<TItem> = page.data;\n\n    const cells: ITileCell<TItem>[] = items || [];\n\n    const grids: React.ReactNode[] = [];\n\n    const previousCell = this.state.cells[page.startIndex - 1];\n    const nextCell = this.state.cells[page.startIndex + page.itemCount];\n\n    const endIndex = cells.length;\n\n    let currentRow: IRowData | undefined;\n    let currentRowCells = [];\n\n    let shimmerWrapperWidth = 0;\n\n    for (let i = 0; i < endIndex; ) {\n      // For each cell at the start of a grid.\n      const grid = cells[i].grid;\n\n      const { isPlaceholder, maxRowCount } = grid;\n\n      const renderedCells: React.ReactNode[] = [];\n\n      const width = data.pageWidths[page.startIndex + i];\n\n      let rowCount = 0;\n      let isAtMaxRowCount = false;\n      let columnIndex = 0;\n\n      for (; i < endIndex && cells[i].grid === grid; i++) {\n        // For each cell in the current grid.\n        const cell = cells[i];\n\n        const index = page.startIndex + i;\n        const cellAsFirstRow = data.rows[index];\n\n        if (cellAsFirstRow) {\n          if (currentRowCells.length > 0) {\n            renderedCells.push(\n              finalOnRenderRow({\n                cellElements: currentRowCells,\n                divProps: {\n                  className: TilesListStyles.row,\n                  role: 'presentation',\n                },\n              }),\n            );\n            currentRowCells = [];\n          }\n\n          if (cellAsFirstRow !== currentRow) {\n            rowCount++;\n          }\n\n          if (typeof maxRowCount === 'number' && rowCount > maxRowCount) {\n            isAtMaxRowCount = true;\n            break;\n          }\n\n          currentRow = cellAsFirstRow;\n          columnIndex = 0;\n        }\n\n        let finalSize = data.cellSizes[index];\n\n        if (currentRow) {\n          const { scaleFactor, isLastRow, maxScaleFactor: currentRowMaxScaleFactor } = currentRow;\n\n          if (currentRowMaxScaleFactor) {\n            // If the current row has its own max scale factor,\n            // compute final size from the provided value.\n            const finalScaleFactor = Math.min(currentRowMaxScaleFactor, grid.maxScaleFactor);\n\n            finalSize = {\n              width: finalSize.width * finalScaleFactor,\n              height: grid.mode === TilesGridMode.fill ? finalSize.height * finalScaleFactor : grid.minRowHeight,\n            };\n          } else if (\n            (grid.mode === TilesGridMode.fill || grid.mode === TilesGridMode.fillHorizontal) &&\n            (!isLastRow || scaleFactor <= grid.maxScaleFactor)\n          ) {\n            // Compute the final size from the overall max scale factor, if present.\n            const finalScaleFactor = Math.min(grid.maxScaleFactor, scaleFactor);\n\n            finalSize = {\n              width: finalSize.width * finalScaleFactor,\n              height: grid.mode === TilesGridMode.fill ? finalSize.height * finalScaleFactor : grid.minRowHeight,\n            };\n          }\n        }\n\n        const renderedCell = (keyOffset: number = 0): JSX.Element => {\n          return (\n            <div\n              key={`${grid.key}-item-${cell.key}${keyOffset ? '-' + keyOffset : ''}`}\n              data-list-index={index}\n              role={role ? 'presentation' : 'listitem'}\n              className={css('ms-List-cell', this._onGetCellClassName(), {\n                [`ms-TilesList-cell--firstInRow ${TilesListStyles.cellFirstInRow}`]: !!cellAsFirstRow,\n              })}\n              data-automationid=\"ListCell\"\n              style={{\n                ...this._onGetCellStyle(cell, currentRow),\n              }}\n            >\n              {this._onRenderCell(cell, finalSize, columnIndex + keyOffset)}\n            </div>\n          );\n        };\n\n        if (cell.isPlaceholder && grid.mode !== TilesGridMode.none) {\n          const cellsPerRow = Math.floor(width / (grid.spacing + finalSize.width));\n          const totalPlaceholderItems = cellsPerRow * ROWS_OF_PLACEHOLDER_CELLS;\n          shimmerWrapperWidth = cellsPerRow * finalSize.width + grid.spacing * (cellsPerRow - 1);\n          for (let j = 0; j < totalPlaceholderItems; j++) {\n            currentRowCells.push(renderedCell(j));\n          }\n        } else {\n          shimmerWrapperWidth = finalSize.width / 3;\n          currentRowCells.push(renderedCell());\n        }\n\n        columnIndex++;\n      }\n\n      if (isAtMaxRowCount) {\n        for (; i < endIndex && cells[i].grid === grid; i++) {\n          // Consume the rest of the grid.\n        }\n      }\n\n      const isOpenStart = previousCell && previousCell.grid === grid;\n      const isOpenEnd = nextCell && nextCell.grid === grid;\n\n      const margin = grid.spacing / 2;\n\n      if (currentRowCells.length > 0) {\n        renderedCells.push(\n          finalOnRenderRow({\n            cellElements: currentRowCells,\n            divProps: {\n              className: css(TilesListStyles.row, {\n                [TilesListStyles.headerRow]: grid.mode === TilesGridMode.none,\n              }),\n              role: 'presentation',\n            },\n          }),\n        );\n        currentRowCells = [];\n      }\n\n      const finalGrid: JSX.Element = (\n        <div\n          key={grid.key}\n          role=\"presentation\"\n          className={css('ms-TilesList-grid', {\n            [`${TilesListStyles.grid}`]: grid.mode !== TilesGridMode.none,\n            [`${TilesListStyles.shimmeredList}`]: isPlaceholder,\n          })}\n          style={{\n            width: `${width}px`,\n            margin: `${-margin}px`,\n            marginTop: isOpenStart ? '0' : `${grid.marginTop - margin}px`,\n            marginBottom: isOpenEnd ? '0' : `${grid.marginBottom - margin}px`,\n          }}\n        >\n          {renderedCells}\n        </div>\n      );\n\n      grids.push(\n        isPlaceholder ? <Shimmer key={i} customElementsGroup={finalGrid} width={shimmerWrapperWidth} /> : finalGrid,\n      );\n    }\n\n    return (\n      <div role=\"presentation\" {...divProps} className={css(pageClassName, this._onGetPageClassName())}>\n        {grids}\n      </div>\n    );\n  };\n\n  /**\n   * Gets the specification for the list page, which requires pre-calculating the flexbox layout\n   * to determine the set of tiles which fit neatly within a rectangle. Any tiles left dangling\n   * at the end of a page are overflowed into the next page unless they are just before a grid\n   * boundary.\n   */\n  private _getPageSpecification = (\n    startIndex: number,\n    bounds: IRectangle,\n  ): {\n    itemCount: number;\n    data: IPageData<TItem>;\n  } => {\n    if (this._pageSpecificationCache) {\n      if (this._pageSpecificationCache.width !== bounds.width) {\n        this._pageSpecificationCache = undefined;\n      }\n    }\n\n    if (!this._pageSpecificationCache) {\n      this._pageSpecificationCache = {\n        width: bounds.width,\n        byIndex: {},\n      };\n    }\n\n    const pageSpecificationCache = this._pageSpecificationCache;\n\n    if (pageSpecificationCache.byIndex[startIndex]) {\n      // If the page specification has already been calculated, return it.\n      // List recalculates all pages if any input changes, so this memoization\n      // cuts down on calculation of individual pages without changes.\n      return pageSpecificationCache.byIndex[startIndex];\n    }\n\n    const { cells } = this.state;\n    const { cellsPerPage = CELLS_PER_PAGE } = this.props;\n\n    const endIndex = Math.min(cells.length, startIndex + cellsPerPage);\n\n    let rowWidth = 0;\n    let rowStart = 0;\n    let i = startIndex;\n\n    let isAtGridEnd = true;\n\n    const startCells: IPageData<TItem>['rows'] = {};\n    let extraCells: IPageData<TItem>['extraCells'] | undefined;\n    const cellSizes: IPageData<TItem>['cellSizes'] = {};\n    const widths: IPageData<TItem>['pageWidths'] = {};\n\n    for (; i < endIndex; ) {\n      // For each cell at the start of a grid.\n      const grid = cells[i].grid;\n\n      const { maxRowCount } = grid;\n\n      rowWidth = 0;\n      rowStart = i;\n\n      const boundsWidth = bounds.width + grid.spacing;\n\n      widths[i] = boundsWidth;\n\n      let currentRow: IRowData = (startCells[i] = {\n        scaleFactor: 1,\n        cellCount: 0,\n      });\n\n      if (grid.mode === TilesGridMode.none) {\n        // The current \"grid\" just takes up the full width.\n        // No flex calculations necessary.\n        isAtGridEnd = true;\n        cellSizes[i] = {\n          width: bounds.width,\n          height: 0,\n        };\n        currentRow.cellCount++;\n        i++;\n        continue;\n      }\n\n      let rowCount = 0;\n      let isAtMaxRowCount = false;\n\n      for (; i < endIndex && cells[i].grid === grid; i++) {\n        if (typeof maxRowCount === 'number' && rowCount >= maxRowCount) {\n          isAtMaxRowCount = true;\n          break;\n        }\n\n        // For each cell in the current grid.\n        const { aspectRatio } = cells[i];\n\n        const width = aspectRatio * grid.minRowHeight + grid.spacing;\n\n        if (rowWidth + width > boundsWidth) {\n          const totalMargin = grid.spacing * (i - rowStart);\n          currentRow.scaleFactor = (boundsWidth - totalMargin) / (rowWidth - totalMargin);\n        }\n\n        rowWidth += width;\n\n        cellSizes[i] = {\n          // Assign the expected base size of the cell.\n          // Scaling will be handled at render time.\n          width: aspectRatio * grid.minRowHeight,\n          height: grid.minRowHeight,\n        };\n\n        if (rowWidth > boundsWidth) {\n          rowWidth = width;\n          rowStart = i;\n          // Add a marker for a new row, with the default scale factor.\n          currentRow = startCells[i] = {\n            scaleFactor: 1,\n            cellCount: 0,\n          };\n\n          rowCount++;\n        }\n\n        currentRow.cellCount++;\n      }\n\n      if (!cells[i] || cells[i].grid !== grid || isAtMaxRowCount) {\n        // If the next cell is part of a different grid.\n        currentRow.isLastRow = true;\n      } else {\n        isAtGridEnd = false;\n      }\n\n      if (rowWidth < boundsWidth) {\n        const totalMargin = grid.spacing * (i - rowStart);\n        currentRow.scaleFactor = (boundsWidth - totalMargin) / (rowWidth - totalMargin);\n\n        if ((grid.mode === TilesGridMode.fill || grid.mode === TilesGridMode.fillHorizontal) && currentRow.isLastRow) {\n          if (i - rowStart > 0) {\n            // If the grid is in 'fill' mode, and there is underflow in the last row, then by default, flexbox will\n            // scale all widths to the maximum possible, which may cause regularly-sized items to be larger than\n            // those in previous rows.\n            // A way to counter that is to pretend that the last row is actually filled with more items, and calculate\n            // the resulting scale factor. Then pass the new maximum width to flexbox.\n            // The result should be perfectly-aligned final items.\n            // The 'phantom' items are not actually rendered in the list.\n\n            // Project the average tile width across the rest of the row.\n            const width = (rowWidth - totalMargin) / (i - rowStart) + grid.spacing;\n\n            let phantomRowWidth = rowWidth;\n\n            for (let j = i; ; j++) {\n              if (phantomRowWidth + width > boundsWidth) {\n                // The final phantom item has been added, so the row is complete.\n                const phantomTotalMargin = grid.spacing * (j - rowStart);\n                // Set the new scale factor based on the total width including the phantom items.\n                currentRow.maxScaleFactor = (boundsWidth - phantomTotalMargin) / (phantomRowWidth - phantomTotalMargin);\n                break;\n              }\n\n              phantomRowWidth += width;\n            }\n          }\n        }\n      }\n\n      if (\n        !isAtGridEnd &&\n        currentRow.scaleFactor >\n          (grid.mode === TilesGridMode.fill || grid.mode === TilesGridMode.fillHorizontal ? grid.maxScaleFactor : 1)\n      ) {\n        // If the last computed row is not the end of the grid, and the content cannot scale to fit the width,\n        // declare these cells as 'extra' and let them be pushed into the next page.\n        extraCells = cells.slice(rowStart, i);\n      }\n\n      if (isAtMaxRowCount) {\n        while (i < cells.length && cells[i].grid === grid) {\n          // Consume the rest of the cells in the grid if the max row count has been achieved.\n          i++;\n        }\n      }\n    }\n\n    // If there are extra cells, cut off the page so the extra cells will be pushed into the next page.\n    // Otherwise, take all the cells.\n    const itemCount = i - (extraCells ? extraCells.length : 0) - startIndex;\n\n    const pageSpecification: IPageSpecification<TItem> = {\n      itemCount: itemCount,\n      data: {\n        pageWidths: widths,\n        rows: startCells,\n        extraCells: extraCells,\n        cellSizes: cellSizes,\n      },\n    };\n\n    pageSpecificationCache.byIndex[startIndex] = pageSpecification;\n\n    return pageSpecification;\n  };\n\n  private _renderRow: IRenderFunction<ITilesListRowProps<TItem>> = (props: ITilesListRowProps<TItem>): JSX.Element => {\n    const { cellElements, divProps } = props;\n\n    return (\n      <div role=\"presentation\" {...divProps}>\n        {cellElements}\n      </div>\n    );\n  };\n\n  private _onGetCellClassName = (): string => {\n    return TilesListStyles.listCell;\n  };\n\n  private _onGetPageClassName = (): string => {\n    return TilesListStyles.listPage;\n  };\n\n  /**\n   * Get the style to be applied to a single list cell, which will specify the flex behavior\n   * within the flexbox layout.\n   */\n  private _onGetCellStyle = (item: ITileCell<TItem>, currentRow?: IRowData): React.CSSProperties => {\n    const {\n      grid: { mode: gridMode, maxScaleFactor },\n      grid,\n    } = item;\n\n    if (gridMode === TilesGridMode.none) {\n      return {};\n    }\n\n    const itemWidthOverHeight = item.aspectRatio || 1;\n    const margin = grid.spacing / 2;\n    const isFill = gridMode === TilesGridMode.fill || gridMode === TilesGridMode.fillHorizontal;\n    const width = itemWidthOverHeight * grid.minRowHeight;\n\n    let maxWidth: number;\n\n    if (currentRow && currentRow.maxScaleFactor) {\n      // If the row has its own max scale factor, force flexbox to limit at that value.\n      // This typically happens if there is underflow in the final row of a grid.\n      maxWidth = width * Math.min(currentRow.maxScaleFactor, maxScaleFactor);\n    } else if (isFill && (!currentRow || !currentRow.isLastRow || currentRow.scaleFactor <= maxScaleFactor)) {\n      // If the entire grid has a max scale factor, use that limit.\n      maxWidth = width * maxScaleFactor;\n    } else {\n      maxWidth = width;\n    }\n\n    return {\n      flex: isFill ? `${itemWidthOverHeight} ${itemWidthOverHeight} ${width}px` : `0 0 ${width}px`,\n      maxWidth: `${maxWidth}px`,\n      margin: !item.isPlaceholder ? `${margin}px` : 0,\n      borderStyle: item.isPlaceholder ? 'solid' : 'none',\n      borderWidth: item.isPlaceholder ? `${margin}px` : 0,\n    };\n  };\n\n  /**\n   * Flattens the grid and item specifications into a cell list. List will partition the cells into\n   * pages use `getPageSpecification`, so each cell is marked up with metadata to assist the flexbox\n   * algorithm.\n   */\n  private _getCells(items: (ITilesGridSegment<TItem> | ITilesGridItem<TItem>)[]): ITileCell<TItem>[] {\n    const cells: ITileCell<TItem>[] = [];\n\n    for (const item of items) {\n      if (isGridSegment(item)) {\n        // The item is a grid of child items.\n        const {\n          spacing = 0,\n          maxScaleFactor = MAX_TILE_STRETCH,\n          marginBottom = 0,\n          marginTop = 0,\n          minAspectRatio = MIN_ASPECT_RATIO,\n          maxAspectRatio = MAX_ASPECT_RATIO,\n        } = item;\n\n        const grid: ITileGrid = {\n          minRowHeight: item.minRowHeight,\n          spacing: spacing,\n          mode: item.mode,\n          key: `grid-${item.key}`,\n          maxScaleFactor: maxScaleFactor,\n          marginTop: item.isPlaceholder ? 0 : marginTop,\n          marginBottom: item.isPlaceholder ? 0 : marginBottom,\n          isPlaceholder: item.isPlaceholder,\n          maxRowCount: item.maxRowCount,\n        };\n\n        for (const gridItem of item.items) {\n          const { desiredSize, onRender: itemOnRender, onRenderCell } = gridItem;\n\n          const aspectRatio = Math.min(\n            maxAspectRatio,\n            Math.max(minAspectRatio, (desiredSize && desiredSize.width / desiredSize.height) || 1),\n          );\n\n          const onRender =\n            onRenderCell ||\n            ((props: ITilesGridItemCellProps<TItem>) => {\n              if (!itemOnRender) {\n                return null;\n              }\n\n              return itemOnRender(props.item, props.finalSize);\n            });\n\n          cells.push({\n            aspectRatio: aspectRatio,\n            content: gridItem.content,\n            onRender,\n            grid: grid,\n            key: gridItem.key,\n            isPlaceholder: gridItem.isPlaceholder,\n            desiredHeight: desiredSize ? desiredSize.height : undefined,\n          });\n        }\n      } else {\n        const { onRenderCell, onRender: itemOnRender } = item;\n\n        const onRender =\n          onRenderCell ||\n          ((props: ITilesGridItemCellProps<TItem>) => {\n            if (!itemOnRender) {\n              return null;\n            }\n\n            return itemOnRender(props.item, props.finalSize);\n          });\n\n        // The item is not part of the grid, and should take up a whole row.\n        cells.push({\n          aspectRatio: 1,\n          content: item.content,\n          onRender,\n          grid: {\n            minRowHeight: 0,\n            spacing: 0,\n            mode: TilesGridMode.none,\n            key: `grid-header-${item.key}`,\n            maxScaleFactor: 1,\n            marginBottom: 0,\n            marginTop: 0,\n            isPlaceholder: item.isPlaceholder,\n          },\n          key: `header-${item.key}`,\n          isPlaceholder: item.isPlaceholder,\n        });\n      }\n    }\n\n    return cells;\n  }\n}\n\nfunction isGridSegment<TItem>(\n  item: ITilesGridSegment<TItem> | ITilesGridItem<TItem>,\n): item is ITilesGridSegment<TItem> {\n  return !!(item as ITilesGridSegment<TItem>).items;\n}\n"]}